{"name":"Vaultsharp","tagline":"A .NET Library for HashiCorp's Vault - A Secret Management System.","body":"# VaultSharp\r\nA .NET Library for HashiCorp's Vault - A Secret Management System.\r\n\r\n## Nuget Package: https://www.nuget.org/packages/VaultSharp/\r\n\r\n## Documentation Site: http://rajanadar.github.io/VaultSharp/\r\n\r\n### What is VaultSharp?\r\n\r\n* VaultSharp is a C# Library that can be used in any .NET application to interact with Hashicorp's Vault Service.\r\n* The Vault system is a secret management system built as an Http Service by Hashicorp. \r\n* This library supports all the Vault Service Apis documented here: https://www.vaultproject.io/docs/http/\r\n\r\n### What is the deal with the Versioning of VaultSharp? (Y U NO 1.0.0)\r\n\r\n* This library is written for the Vault Service version 0.4.0\r\n* The Vault service is evolving constantly and the Hashicorp team is rapidly working on it.\r\n* Pretty soon, we should have an 1.0.0 version of the Vault Service from Hashicorp.\r\n* Because this client library is intended to facilititate the Vault Service operations, this library makes it easier for its consumers to relate to the Vault service it supports.\r\n* Hence a version of 0.4.x denotes that this library will completely support the Vault 0.4.x Service Apis.\r\n* Tomorrow when Vault Service gets upgraded to 0.5.x, this library will be modified accordingly and versioned as 0.5.x\r\n\r\n### How do I use VaultSharp? Give me a code example\r\n\r\n* Add a Nuget reference from here: https://www.nuget.org/packages/VaultSharp/\r\n* Instantiate a IVaultClient as follows:\r\n\r\n```cs\r\n// instantiate VaultClient with one of the various authentication options available.\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, authenticationInfo);\r\n\r\n// use it for operations.\r\nvar consulCredentials = await vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRoleName, consulMountPoint);\r\nvar consulToken = consulCredentials.Data.Token;\r\n```\r\n\r\n### VaultSharp and 100% Consul Support\r\n\r\n* VaultSharp supports all the secret backends supported by the Vault 0.4.0 Service.\r\n* This includes 100% support for a Consul Secret backend, which is the recommended secret backend for Vault.\r\n* Please look at the API usage in the 'Consul' section of 'Secret Backends' below, to see all the Consul related methods in action.\r\n\r\n### The fundamental READ and WRITE operations on a Vault\r\n\r\n* The generic READ/WRITE Apis of vault allow you to do a variety of operations.\r\n* A lot or almost all of these operations are supported in a strongly typed manner with dedicated methods for them in this library.\r\n* However, for some reason, if you want to use the generic READ and WRITE methods of Vault, you can use them as follows:\r\n\r\n```cs\r\nvar path = \"cubbyhole/foo/test\";\r\n\r\nvar secretData = new Dictionary<string, object>\r\n{\r\n    {\"1\", \"1\"},\r\n    {\"2\", 2},\r\n    {\"3\", false},\r\n};\r\n\r\nawait _authenticatedClient.WriteSecretAsync(path, secretData);\r\n\r\nvar secret = await _authenticatedClient.ReadSecretAsync(path);\r\nvar data = secret.Data; // this is the original dictionary back.\r\n```\r\n\r\n### Can I use it in my PowerShell Automation?\r\n\r\n* Absolutely. VaultSharp is a .NET Library. \r\n* This means, apart from using it in your C#, VB.NET, J#.NET and any .NET application, you can use it in PowerShell automation as well.\r\n* Load up the DLL in your PowerShell code and execute the methods. PowerShell can totally work with .NET Dlls.\r\n\r\n### All the methods are async. How do I use them synchronously?\r\n\r\n* The methods are async as the defacto implementation. The recommended usage.\r\n* However, there are innumerable scenarios where you would continue to want to use it synchronously.\r\n* For all those cases, there are various options available to you.\r\n* There is a lot of discussion around the right usage, avoiding deadlocks etc.\r\n* This library allows you to set the 'continueAsyncTasksOnCapturedContext' option when you initialize the client.\r\n* It is an optional parameter and defaults to 'false'\r\n* Setting it to false, allows you to access the .Result property of the task with reduced/zero deadlock issues.\r\n* There are other ways as well to invoke it synchronously, and  I leave it to you guys. (Task.Run etc.) \r\n* But please note that as much as possible, use it in an async manner. \r\n\r\n```cs\r\n\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, authenticationInfo, continueAsyncTasksOnCapturedContext: true);\r\n\r\nvar consulSecret = vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRole).Result;\r\n\r\n```\r\n\r\n### Authentication Backends (All of them are supported)\r\n\r\n* VaultSharp supports all the authentication backends supported by the Vault Service 0.4.0\r\n* Here is a sample to instantiate the vault client with each of the authentication backends.\r\n\r\n#### App Id Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo appIdAuthenticationInfo = new AppIdAuthenticationInfo(mountPoint, appId, userId);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, appIdAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the app id and user id.\r\n\r\n```\r\n\r\n#### GitHub Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo gitHubAuthenticationInfo = new GitHubAuthenticationInfo(mountPoint, personalAccessToken);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, gitHubAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the github token.\r\n\r\n```\r\n\r\n#### LDAP Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo ldapAuthenticationInfo = new LDAPAuthenticationInfo(mountPoint, username, password);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, ldapAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the LDAP username and password.\r\n\r\n```\r\n\r\n#### GitHub Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo gitHubAuthenticationInfo = new GitHubAuthenticationInfo(mountPoint, personalAccessToken);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, gitHubAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the github token.\r\n\r\n```\r\n\r\n#### Certificate (TLS) Authentication Backend\r\n\r\n```cs\r\nvar clientCertificate = new X509Certificate2(certificatePath, certificatePassword, X509KeyStorageFlags.Exportable | X509KeyStorageFlags.PersistKeySet);\r\n\r\nIAuthenticationInfo certificateAuthenticationInfo = new CertificateAuthenticationInfo(mountPoint, clientCertificate);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, certificateAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the client certificate.\r\n\r\n```\r\n\r\n#### Token Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo tokenAuthenticationInfo = new TokenAuthenticationInfo(mountPoint, vaultToken);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, tokenAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the vault token.\r\n\r\n```\r\n\r\n#### Username and Password Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo usernamePasswordAuthenticationInfo = new UsernamePasswordAuthenticationInfo(mountPoint, username, password);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, usernamePasswordAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the username/password.\r\n\r\n```\r\n\r\n### Secret Backends (All of them are supported)\r\n\r\n* VaultSharp supports all the secret backends supported by the Vault Service 0.4.0\r\n* Here is a sample to instantiate the vault client with each of the secret backends.\r\n\r\n#### AWS Secret Backend\r\n\r\n##### Configuring an AWS Backend\r\n\r\n```cs\r\n// mount the backend\r\nawait vaultClient.MountSecretBackendAsync(new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.AWS\r\n});\r\n\r\n// configure root credentials to create/manage roles and generate credentials\r\nawait vaultClient.AWSConfigureRootCredentialsAsync(new AWSRootCredentials\r\n{\r\n    AccessKey = \"access-key\",\r\n    SecretKey = \"secret-key\",\r\n    Region = \"region\"\r\n});\r\n\r\n// create a named role with the IAM policy\r\nawait vaultClient.AWSWriteNamedRoleAsync(\"myAwsRole\", new AWSRoleDefinition\r\n{\r\n    Policy = \"iam-policy-contents\"\r\n});\r\n```\r\n\r\n##### Generate AWS Credentials\r\n\r\n```cs\r\nvar awsCredentials = await vaultClient.AWSGenerateDynamicCredentialsAsync(\"myAwsRole\");\r\nvar awsAccessKey = awsCredentials.Data.AccessKey;\r\nvar awsSecretKey = awsCredentials.Data.SecretKey;\r\n\r\n```\r\n\r\n#### Cassandra Secret Backend\r\n\r\n##### Configuring a Cassandra Backend\r\n\r\n```cs\r\n// mount the backend\r\nawait vaultClient.MountSecretBackendAsync(new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.Cassandra\r\n});\r\n\r\n// configure root connection info to create/manage roles and generate credentials\r\nawait vaultClient.CassandraConfigureConnectionAsync(new CassandraConnectionInfo\r\n{\r\n    Hosts = \"hosts\",\r\n    Username = \"username\",\r\n    Password = \"password\"\r\n});\r\n\r\n// create a named role\r\nawait vaultClient.CassandraWriteNamedRoleAsync(\"myCassandraRole\", new CassandraRoleDefinition\r\n{\r\n    CreationCql = \"csql\"\r\n});\r\n```\r\n\r\n##### Generate Cassandra Credentials\r\n\r\n```cs\r\nvar cassandraCredentials = await vaultClient.CassandraGenerateDynamicCredentialsAsync(\"myCassandraRole\");\r\nvar cassandraUsername = cassandraCredentials.Data.Username;\r\nvar cassandraPassword = cassandraCredentials.Data.Password;\r\n\r\n```\r\n#### Consul Secret Backend\r\n\r\n##### Configuring a Consul Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar consulAddress = \"127.0.0.1:8500\";\r\nvar consulAclMasterToken = \"raja\";\r\n\r\nvar backend = new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.Consul,\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\n// configure access to Consul and create roles\r\nvar consulRole = \"consulRole\";\r\n\r\nawait vaultClient.ConsulConfigureAccessAsync(new ConsulAccessInfo()\r\n{\r\n    AddressWithPort = consulAddress,\r\n    ManagementToken = consulAclMasterToken\r\n});\r\n\r\n// create a named role\r\nawait vaultClient.ConsulWriteNamedRoleAsync(consulRole, new ConsulRoleDefinition()\r\n{\r\n    TokenType = ConsulTokenType.management,\r\n});\r\n\r\nvar readRole = await vaultClient.ConsulReadNamedRoleAsync(consulRole);\r\nAssert.Equal(ConsulTokenType.management, readRole.Data.TokenType);\r\n```\r\n\r\n##### Generate Consul Credentials\r\n\r\n```cs\r\nvar consulCredentials = await vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRole);\r\nvar consulToken = consulCredentials.Data.Token;\r\n```\r\n\r\n##### Deleting Role and Unmounting the Consul backend\r\n\r\n```cs\r\nawait vaultClient.ConsulDeleteNamedRoleAsync(consulRole);\r\nawait vaultClient.UnmountSecretBackendAsync(SecretBackendType.Consul.Type);\r\n\r\n```\r\n\r\n#### Cubbyhole Secret Backend\r\n\r\n```cs\r\nvar path = \"cubbyhole/foo1/foo2\";\r\nvar values = new Dictionary<string, object>\r\n{\r\n    {\"foo\", \"bar\"},\r\n    {\"foo2\", 345 }\r\n};\r\n\r\nawait vaultClient.CubbyholeWriteSecretAsync(path, values);\r\n\r\nvar readValues = await vaultClient.CubbyholeReadSecretAsync(path);\r\nvar data = readValues.Data; // gives back the dictionary\r\n\r\nawait vaultClient.CubbyholeDeleteSecretAsync(path);\r\n\r\n```\r\n","google":"UA-72715364-1","note":"Don't delete this file! It's used internally to help with page regeneration."}