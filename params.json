{
  "name": "VaultSharp",
  "tagline": "A .NET Library for HashiCorp's Vault - A Secret Management System.",
  "body": "\r\n## VaultSharp 0.6.1 is now released and available via NuGet.\r\n### VaultSharp 0.6.1 supports all backends (auth + secret) of Vault 0.6.1\r\n\r\n# VaultSharp\r\nA .NET Library for HashiCorp's Vault - A Secret Management System.\r\n\r\n## Nuget Package: https://www.nuget.org/packages/VaultSharp/\r\n\r\n## Documentation Site: http://rajanadar.github.io/VaultSharp/\r\n\r\n## Report Feedback/Issues Here: https://github.com/rajanadar/VaultSharp/issues/new\r\n\r\n**Table of Contents**\r\n\r\n- [VaultSharp](#vaultsharp)\r\n\t- [Nuget Package: https://www.nuget.org/packages/VaultSharp/](#nuget-package-httpswwwnugetorgpackagesvaultsharp)\r\n\t- [Documentation Site: http://rajanadar.github.io/VaultSharp/](#documentation-site-httprajanadargithubiovaultsharp)\r\n\t\t- [What is VaultSharp?](#what-is-vaultsharp)\r\n\t\t- [VaultSharp 0.4.x should completely support Vault Service 0.4.0](#vaultsharp-04x-should-completely-support-vault-service-040)\r\n\t\t- [What is the deal with the Versioning of VaultSharp? (Y U NO 1.0.0)](#what-is-the-deal-with-the-versioning-of-vaultsharp-y-u-no-100)\r\n\t\t- [How do I use VaultSharp? Give me a code example](#how-do-i-use-vaultsharp-give-me-a-code-example)\r\n\t\t- [Does VaultSharp support all the Authentication, Secret and Audit Backends?](#does-vaultsharp-support-all-the-authentication-secret-and-audit-backends)\r\n\t\t- [VaultSharp and 100% Consul Support](#vaultsharp-and-100-consul-support)\r\n\t\t- [The fundamental READ and WRITE operations on a Vault](#the-fundamental-read-and-write-operations-on-a-vault)\r\n\t\t- [Can I use it in my PowerShell Automation?](#can-i-use-it-in-my-powershell-automation)\r\n\t\t- [All the methods are async. How do I use them synchronously?](#all-the-methods-are-async-how-do-i-use-them-synchronously)\r\n\t\t- [Authentication Backends (All of them are supported)](#authentication-backends-all-of-them-are-supported)\r\n\t\t\t- [App Id Authentication Backend](#app-id-authentication-backend)\r\n\t\t\t- [App Role Authentication Backend](#app-role-authentication-backend)\r\n\t\t\t- [AWS-EC2 Authentication Backend](#aws-ec2-authentication-backend)\r\n\t\t\t- [GitHub Authentication Backend](#github-authentication-backend)\r\n\t\t\t- [LDAP Authentication Backend](#ldap-authentication-backend)\r\n\t\t\t- [Certificate (TLS) Authentication Backend](#certificate-tls-authentication-backend)\r\n\t\t\t- [Token Authentication Backend](#token-authentication-backend)\r\n\t\t\t- [Username and Password Authentication Backend](#username-and-password-authentication-backend)\r\n\t\t- [Secret Backends (All of them are supported)](#secret-backends-all-of-them-are-supported)\r\n\t\t\t- [AWS Secret Backend](#aws-secret-backend)\r\n\t\t\t\t- [Configuring an AWS Backend](#configuring-an-aws-backend)\r\n\t\t\t\t- [Generate AWS Credentials](#generate-aws-credentials)\r\n\t\t\t- [Cassandra Secret Backend](#cassandra-secret-backend)\r\n\t\t\t\t- [Configuring a Cassandra Backend](#configuring-a-cassandra-backend)\r\n\t\t\t\t- [Generate Cassandra Credentials](#generate-cassandra-credentials)\r\n\t\t\t- [Consul Secret Backend](#consul-secret-backend)\r\n\t\t\t\t- [Configuring a Consul Backend](#configuring-a-consul-backend)\r\n\t\t\t\t- [Generate Consul Credentials](#generate-consul-credentials)\r\n\t\t\t\t- [Deleting Role and Unmounting the Consul backend](#deleting-role-and-unmounting-the-consul-backend)\r\n\t\t\t- [Cubbyhole Secret Backend](#cubbyhole-secret-backend)\r\n\t\t\t- [Generic Secret Backend](#generic-secret-backend)\r\n\t\t\t- [MongoDB Secret Backend](#mongodb-secret-backend)\r\n\t\t\t\t- [Configuring a MongoDB Backend](#configuring-a-mongodb-backend)\r\n\t\t\t\t- [Generate MongoDB Credentials](#generate-mongodb-credentials)\r\n\t\t\t- [MSSQL Secret Backend](#mssql-secret-backend)\r\n\t\t\t\t- [Configuring a MSSQL Backend](#configuring-a-mssql-backend)\r\n\t\t\t\t- [Generate MSSQL Credentials](#generate-mssql-credentials)\r\n\t\t\t- [MySql Secret Backend](#mysql-secret-backend)\r\n\t\t\t\t- [Configuring a MySql Backend](#configuring-a-mysql-backend)\r\n\t\t\t\t- [Generate MySql Credentials](#generate-mysql-credentials)\r\n\t\t\t- [PKI (Certificates) Secret Backend](#pki-certificates-secret-backend)\r\n\t\t\t\t- [Configuring a PKI Backend](#configuring-a-pki-backend)\r\n\t\t\t\t- [Write/Read PKI Role](#writeread-pki-role)\r\n\t\t\t\t- [Generate PKI Credentials](#generate-pki-credentials)\r\n\t\t\t- [PostgreSql Secret Backend](#postgresql-secret-backend)\r\n\t\t\t\t- [Configuring a PostgreSql Backend](#configuring-a-postgresql-backend)\r\n\t\t\t\t- [Generate PostgreSql Credentials](#generate-postgresql-credentials)\r\n\t\t\t- [RabbitMQ Secret Backend](#rabbitmq-secret-backend)\r\n\t\t\t\t- [Configuring a RabbitMQ Backend](#configuring-a-rabbitmq-backend)\r\n\t\t\t\t- [Generate RabbitMQ Credentials](#generate-rabbitmq-credentials)\r\n\t\t\t- [SSH Secret Backend](#ssh-secret-backend)\r\n\t\t\t\t- [Configuring a SSH Backend](#configuring-a-ssh-backend)\r\n\t\t\t\t- [Generate SSH Credentials](#generate-ssh-credentials)\r\n\t\t\t- [Transit Secret Backend](#transit-secret-backend)\r\n\t\t\t\t- [Configuring a Transit Backend](#configuring-a-transit-backend)\r\n\t\t\t\t- [Encrypt/Decrypt text](#encryptdecrypt-text)\r\n\t\t\t\t- [Other Transit Operations](#other-transit-operations)\r\n\t\t- [Audit Backends (All of them are supported)](#audit-backends-all-of-them-are-supported)\r\n\t\t\t- [File Audit Backend](#file-audit-backend)\r\n\t\t\t- [Syslog Audit Backend](#syslog-audit-backend)\r\n\t\t- [More Administrative & Other operations](#more-administrative--other-operations)\r\n\t\t- [Miscellaneous Features](#miscellaneous-features)\r\n\t\t\t- [Quick mount, unseal and rekey methods](#quick-mount-unseal-and-rekey-methods)\r\n\t\t\t- [Setting Proxy Settings, custom Message Handlers etc.](#setting-proxy-settings-custom-message-handlers-etc)\r\n\t\t- [In Conclusion](#in-conclusion)\r\n\r\n### What is VaultSharp?\r\n\r\n* VaultSharp is a C# Library that can be used in any .NET application to interact with Hashicorp's Vault Service.\r\n* The Vault system is a secret management system built as an Http Service by Hashicorp. \r\n* This library supports all the Vault Service Apis documented here: https://www.vaultproject.io/docs/http/\r\n\r\n### VaultSharp 0.6.1 completely supports Hashicorp's Vault 0.6.1\r\n\r\n### What is the deal with the Versioning of VaultSharp? (Y U NO 1.0.0)\r\n\r\n* This library is written for Hashicorp's Vault Service\r\n* The Vault service is evolving constantly and the Hashicorp team is rapidly working on it.\r\n* Pretty soon, they should have an 1.0.0 version of the Vault Service from Hashicorp.\r\n* Because this client library is intended to facilititate the Vault Service operations, this library makes it easier for its consumers to relate to the Vault service it supports.\r\n* Hence a version of 0.6.1 denotes that this library will completely support the Vault 0.6.1 Service Apis.\r\n* Tomorrow when Vault Service gets upgraded to 0.6.2, this library will be modified accordingly and versioned as 0.6.2\r\n\r\n### How do I use VaultSharp? Give me a code example\r\n\r\n* Add a Nuget reference from here: https://www.nuget.org/packages/VaultSharp/\r\n* Instantiate a IVaultClient as follows:\r\n\r\n```cs\r\n// instantiate VaultClient with one of the various authentication options available.\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, authenticationInfo);\r\n\r\n// use it for operations.\r\nvar consulCredentials = await vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRoleName, consulMountPoint);\r\nvar consulToken = consulCredentials.Data.Token;\r\n```\r\n\r\n### Does VaultSharp support all the Authentication, Secret and Audit Backends?\r\n\r\n* YES\r\n* All Authentication, Secret and Audit backends are supported by this library.\r\n* All administrative (seal, unseal, write policy), end-user (generate credentials) and unauthenticated methods (get status, get root CA) are supported by this client.\r\n\r\n### VaultSharp and 100% Consul Support\r\n\r\n* VaultSharp supports all the secret backends supported by the Vault 0.6.1 Service.\r\n* This includes 100% support for a Consul Secret backend, which is the recommended secret backend for Vault.\r\n* Please look at the API usage in the 'Consul' section of 'Secret Backends' below, to see all the Consul related methods in action.\r\n\r\n### The fundamental READ and WRITE operations on a Vault\r\n\r\n* The generic READ/WRITE Apis of vault allow you to do a variety of operations.\r\n* A lot or almost all of these operations are supported in a strongly typed manner with dedicated methods for them in this library.\r\n* However, for some reason, if you want to use the generic READ and WRITE methods of Vault, you can use them as follows:\r\n\r\n```cs\r\nvar path = \"cubbyhole/foo/test\";\r\n\r\nvar secretData = new Dictionary<string, object>\r\n{\r\n    {\"1\", \"1\"},\r\n    {\"2\", 2},\r\n    {\"3\", false},\r\n};\r\n\r\nawait vaultClient.WriteSecretAsync(path, secretData);\r\n\r\nvar secret = await vaultClient.ReadSecretAsync(path);\r\nvar data = secret.Data; // this is the original dictionary back.\r\n```\r\n\r\n### Can I use it in my PowerShell Automation?\r\n\r\n* Absolutely. VaultSharp is a .NET Library. \r\n* This means, apart from using it in your C#, VB.NET, J#.NET and any .NET application, you can use it in PowerShell automation as well.\r\n* Load up the DLL in your PowerShell code and execute the methods. PowerShell can totally work with .NET Dlls.\r\n\r\n### All the methods are async. How do I use them synchronously?\r\n\r\n* The methods are async as the defacto implementation. The recommended usage.\r\n* However, there are innumerable scenarios where you would continue to want to use it synchronously.\r\n* For all those cases, there are various options available to you.\r\n* There is a lot of discussion around the right usage, avoiding deadlocks etc.\r\n* This library allows you to set the 'continueAsyncTasksOnCapturedContext' option when you initialize the client.\r\n* It is an optional parameter and defaults to 'false'\r\n* Setting it to false, allows you to access the .Result property of the task with reduced/zero deadlock issues.\r\n* There are other ways as well to invoke it synchronously, and  I leave it to you guys. (Task.Run etc.) \r\n* But please note that as much as possible, use it in an async manner. \r\n\r\n```cs\r\n\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, authenticationInfo, continueAsyncTasksOnCapturedContext: true);\r\n\r\nvar consulSecret = vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRole).Result;\r\n\r\n```\r\n\r\n### Authentication Backends (All of them are supported)\r\n\r\n* VaultSharp supports all the authentication backends supported by the Vault Service 0.4.0\r\n* Here is a sample to instantiate the vault client with each of the authentication backends.\r\n\r\n#### App Id Authentication Backend\r\n\r\n* Please note that the app-id auth backend has been deprecated by Vault. They recommend us to use the AppRole backend.\r\n* VaultSharp still lets you use the app-id Apis, for backward compatibility.\r\n* You can use the strongly typed api's to configure the appid and userid as follows.\r\n\r\n```cs\r\n\r\n// Configure app-id roles and users as follows.\r\nawait AdminVaultClient.AppIdAuthenticationConfigureAppId(appId, policy.Name, appId, path);\r\nawait AdminVaultClient.AppIdAuthenticationConfigureUserId(userId, appId, authenticationPath: path);\r\n\r\n// now, setup the app-id based auth to get the right token.\r\n\r\nIAuthenticationInfo appIdAuthenticationInfo = new AppIdAuthenticationInfo(mountPoint, appId, userId);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, appIdAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the app id and user id.\r\n\r\n```\r\n\r\n#### App Role Authentication Backend\r\n\r\n```cs\r\n\r\n// setup the AppRole based auth to get the right token.\r\n\r\nIAuthenticationInfo appRoleAuthenticationInfo = new AppRoleAuthenticationInfo(mountPoint, roleId, secretId);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, appRoleAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the app role and secret id.\r\n\r\n```\r\n\r\n#### AWS-EC2 Authentication Backend\r\n\r\n```cs\r\n\r\n// setup the AWS-EC2 based auth to get the right token.\r\n\r\nIAuthenticationInfo awsEc2AuthenticationInfo = new AwcEc2AuthenticationInfo(mountPoint, pkcs7, nonce, roleName);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, awsEc2AuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the aws-ec2 role\r\n\r\n```\r\n\r\n#### GitHub Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo gitHubAuthenticationInfo = new GitHubAuthenticationInfo(mountPoint, personalAccessToken);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, gitHubAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the github token.\r\n\r\n```\r\n\r\n#### LDAP Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo ldapAuthenticationInfo = new LDAPAuthenticationInfo(mountPoint, username, password);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, ldapAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the LDAP username and password.\r\n\r\n```\r\n\r\n#### Certificate (TLS) Authentication Backend\r\n\r\n```cs\r\nvar clientCertificate = new X509Certificate2(certificatePath, certificatePassword, X509KeyStorageFlags.Exportable | X509KeyStorageFlags.PersistKeySet);\r\n\r\nIAuthenticationInfo certificateAuthenticationInfo = new CertificateAuthenticationInfo(mountPoint, clientCertificate);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, certificateAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the client certificate.\r\n\r\n```\r\n\r\n#### Token Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo tokenAuthenticationInfo = new TokenAuthenticationInfo(mountPoint, vaultToken);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, tokenAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the vault token.\r\n\r\n```\r\n\r\n#### Username and Password Authentication Backend\r\n\r\n```cs\r\nIAuthenticationInfo usernamePasswordAuthenticationInfo = new UsernamePasswordAuthenticationInfo(mountPoint, username, password);\r\nIVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, usernamePasswordAuthenticationInfo);\r\n\r\n// any operations done using the vaultClient will use the vault token/policies mapped to the username/password.\r\n\r\n```\r\n\r\n### Secret Backends (All of them are supported)\r\n\r\n* VaultSharp supports all the secret backends supported by the Vault Service 0.4.0\r\n* Here is a sample to instantiate the vault client with each of the secret backends.\r\n\r\n#### AWS Secret Backend\r\n\r\n##### Configuring an AWS Backend\r\n\r\n```cs\r\n// mount the backend\r\nawait vaultClient.MountSecretBackendAsync(new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.AWS\r\n});\r\n\r\n// configure root credentials to create/manage roles and generate credentials\r\nawait vaultClient.AWSConfigureRootCredentialsAsync(new AWSRootCredentials\r\n{\r\n    AccessKey = \"access-key\",\r\n    SecretKey = \"secret-key\",\r\n    Region = \"region\"\r\n});\r\n\r\n// create a named role with the IAM policy\r\nawait vaultClient.AWSWriteNamedRoleAsync(\"myAwsRole\", new AWSRoleDefinition\r\n{\r\n    Policy = \"iam-policy-contents\"\r\n});\r\n```\r\n\r\n##### Generate AWS Credentials\r\n\r\n```cs\r\nvar awsCredentials = await vaultClient.AWSGenerateDynamicCredentialsAsync(\"myAwsRole\");\r\nvar awsAccessKey = awsCredentials.Data.AccessKey;\r\nvar awsSecretKey = awsCredentials.Data.SecretKey;\r\n\r\n```\r\n\r\n#### Cassandra Secret Backend\r\n\r\n##### Configuring a Cassandra Backend\r\n\r\n```cs\r\n// mount the backend\r\nawait vaultClient.MountSecretBackendAsync(new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.Cassandra\r\n});\r\n\r\n// configure root connection info to create/manage roles and generate credentials\r\nawait vaultClient.CassandraConfigureConnectionAsync(new CassandraConnectionInfo\r\n{\r\n    Hosts = \"hosts\",\r\n    Username = \"username\",\r\n    Password = \"password\"\r\n});\r\n\r\n// create a named role\r\nawait vaultClient.CassandraWriteNamedRoleAsync(\"myCassandraRole\", new CassandraRoleDefinition\r\n{\r\n    CreationCql = \"csql\"\r\n});\r\n```\r\n\r\n##### Generate Cassandra Credentials\r\n\r\n```cs\r\nvar cassandraCredentials = await vaultClient.CassandraGenerateDynamicCredentialsAsync(\"myCassandraRole\");\r\nvar cassandraUsername = cassandraCredentials.Data.Username;\r\nvar cassandraPassword = cassandraCredentials.Data.Password;\r\n\r\n```\r\n#### Consul Secret Backend\r\n\r\n##### Configuring a Consul Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar consulAddress = \"127.0.0.1:8500\";\r\nvar consulAclMasterToken = \"raja\";\r\n\r\nvar backend = new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.Consul,\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\n// configure access to Consul and create roles\r\nvar consulRole = \"consulRole\";\r\n\r\nawait vaultClient.ConsulConfigureAccessAsync(new ConsulAccessInfo()\r\n{\r\n    AddressWithPort = consulAddress,\r\n    ManagementToken = consulAclMasterToken\r\n});\r\n\r\n// create a named role\r\nawait vaultClient.ConsulWriteNamedRoleAsync(consulRole, new ConsulRoleDefinition()\r\n{\r\n    TokenType = ConsulTokenType.management,\r\n});\r\n\r\nvar readRole = await vaultClient.ConsulReadNamedRoleAsync(consulRole);\r\nAssert.Equal(ConsulTokenType.management, readRole.Data.TokenType);\r\n```\r\n\r\n##### Generate Consul Credentials\r\n\r\n```cs\r\nvar consulCredentials = await vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRole);\r\nvar consulToken = consulCredentials.Data.Token;\r\n```\r\n\r\n##### Deleting Role and Unmounting the Consul backend\r\n\r\n```cs\r\nawait vaultClient.ConsulDeleteNamedRoleAsync(consulRole);\r\nawait vaultClient.UnmountSecretBackendAsync(SecretBackendType.Consul.Type);\r\n\r\n```\r\n\r\n#### Cubbyhole Secret Backend\r\n\r\n```cs\r\nvar path = \"cubbyhole/foo1/foo2\";\r\nvar values = new Dictionary<string, object>\r\n{\r\n    {\"foo\", \"bar\"},\r\n    {\"foo2\", 345 }\r\n};\r\n\r\nawait vaultClient.CubbyholeWriteSecretAsync(path, values);\r\n\r\nvar readValues = await vaultClient.CubbyholeReadSecretAsync(path);\r\nvar data = readValues.Data; // gives back the dictionary\r\n\r\nawait vaultClient.CubbyholeDeleteSecretAsync(path);\r\n\r\n```\r\n\r\n#### Generic Secret Backend\r\n\r\n```cs\r\nvar mountpoint = \"secret\" + Guid.NewGuid();\r\n\r\nvar path = mountpoint + \"/foo1/blah2\";\r\nvar values = new Dictionary<string, object>\r\n{\r\n    {\"foo\", \"bar\"},\r\n    {\"foo2\", 345 }\r\n};\r\n\r\nawait\r\n    vaultClient.MountSecretBackendAsync(new SecretBackend()\r\n    {\r\n        BackendType = SecretBackendType.Generic,\r\n        MountPoint = mountpoint\r\n    });\r\n\r\nawait vaultClient.GenericWriteSecretAsync(path, values);\r\n\r\nvar readValues = await vaultClient.GenericReadSecretAsync(path);\r\nvar data = readValues.Data; // gives back the dictionary\r\n\r\nawait vaultClient.GenericDeleteSecretAsync(path);\r\n\r\n```\r\n#### MongoDB Secret Backend\r\n\r\n##### Configuring a MongoDB Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar mountPoint = \"mongodb\" + Guid.NewGuid();\r\nvar backend = new SecretBackend\r\n{\r\n    MountPoint = mountPoint,\r\n    BackendType = SecretBackendType.MongoDB,\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\n// configure root connection info to create/manage roles and generate credentials\r\n\r\nvar mongoDbConnectionInfo = new MongoDbConnectionInfo\r\n{\r\n ConnectionStringUri = \"mongodb://root:password@127.0.0.1:27017/admin?ssl=false\"\r\n};\r\n\r\nawait vaultClient.MongoDbConfigureConnectionAsync(mongoDbConnectionInfo, mountPoint);\r\n\r\nvar lease = new CredentialTimeToLiveSettings\r\n{\r\n    TimeToLive = \"1m1s\",\r\n    MaximumTimeToLive = \"2m1s\"\r\n};\r\n\r\nawait vaultClient.MongoDbConfigureCredentialLeaseSettingsAsync(lease);\r\n\r\n// create a named role\r\nvar roleName = \"mongodb-role\";\r\n\r\nvar role = new MongoDbRoleDefinition\r\n{\r\n    Database = \"admin\",\r\n    Roles = JsonConvert.SerializeObject(new object[] { \"readWrite\", new { role = \"read\", db = \"bar\" } })\r\n};\r\n\r\nawait vaultClient.MongoDbWriteNamedRoleAsync(roleName, role);\r\n\r\nvar queriedRole = await vaultClient.MongoDbReadNamedRoleAsync(roleName);\r\n```\r\n\r\n##### Generate MongoDB Credentials\r\n\r\n```cs\r\nvar generatedCreds = await vaultClient.MongoDbGenerateDynamicCredentialsAsync(roleName, mountPoint);\r\n\r\nvar username = generatedCreds.Data.Username;\r\nvar password = generatedCreds.Data.Password;\r\n\r\n```\r\n#### MSSQL Secret Backend\r\n\r\n##### Configuring a MSSQL Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar mountPoint = \"mssql\" + Guid.NewGuid();\r\nvar backend = new SecretBackend\r\n{\r\n    MountPoint = mountPoint,\r\n    BackendType = SecretBackendType.MicrosoftSql,\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\n// configure root connection info to create/manage roles and generate credentials\r\nvar microsoftSqlConnectionInfo = new MicrosoftSqlConnectionInfo\r\n{\r\n    ConnectionString = \"server=localhost\\sqlexpress;port=1433;user id=sa;password=****;database=master;app name=vault\",\r\n    MaximumOpenConnections = 5,\r\n    VerifyConnection = true\r\n};\r\n\r\nawait vaultClient.MicrosoftSqlConfigureConnectionAsync(microsoftSqlConnectionInfo, mountPoint);\r\n\r\nvar lease = new CredentialTtlSettings()\r\n{\r\n    TimeToLive = \"1m1s\",\r\n    MaximumTimeToLive = \"2m1s\"\r\n};\r\n\r\nawait vaultClient.MicrosoftSqlConfigureCredentialLeaseSettingsAsync(lease, mountPoint);\r\n\r\n// create a named role\r\nvar roleName = \"msssqlrole\";\r\n\r\nvar role = new MicrosoftSqlRoleDefinition\r\n{\r\n    Sql = \"CREATE LOGIN '[{{name}}]' WITH PASSWORD = '{{password}}'; USE master; CREATE USER '[{{name}}]' FOR LOGIN '[{{name}}]'; GRANT SELECT ON SCHEMA::dbo TO '[{{name}}]'\"\r\n};\r\n\r\nawait vaultClient.MicrosoftSqlWriteNamedRoleAsync(roleName, role, mountPoint);\r\n\r\nvar queriedRole = await vaultClient.MicrosoftSqlReadNamedRoleAsync(roleName, mountPoint);\r\n```\r\n\r\n##### Generate MSSQL Credentials\r\n\r\n```cs\r\nvar msSqlCredentials = await vaultClient.MicrosoftSqlGenerateDynamicCredentialsAsync(roleName, backend.MountPoint);\r\n\r\nvar msSqlUsername = msSqlCredentials.Data.Username;\r\nvar msSqlPassword = msSqlCredentials.Data.Password;\r\n\r\n```\r\n#### MySql Secret Backend\r\n\r\n##### Configuring a MySql Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar mountPoint = \"mysql\" + Guid.NewGuid();\r\nvar backend = new SecretBackend\r\n{\r\n    MountPoint = mountPoint,\r\n    BackendType = SecretBackendType.MySql,\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\n// configure root connection info to create/manage roles and generate credentials\r\nawait vaultClient.MySqlConfigureConnectionAsync(new MySqlConnectionInfo()\r\n{\r\n    DataSourceName = \"root:root@tcp(127.0.0.1:3306)/\"\r\n}, mountPoint);\r\n\r\nvar sql = \"CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT SELECT ON *.* TO '{{name}}'@'%';\";\r\n\r\nawait vaultClient.MySqlConfigureCredentialLeaseSettingsAsync(new CredentialLeaseSettings()\r\n{\r\n    LeaseDuration = \"1h\",\r\n    MaximumLeaseDuration = \"2h\"\r\n}, mountPoint);\r\n\r\n// create a named role\r\nvar mySqlRole = \"mysql-readonly-role\";\r\n\r\nawait vaultClient.MySqlWriteNamedRoleAsync(mySqlRole, new MySqlRoleDefinition()\r\n{\r\n    Sql = sql\r\n}, mountPoint);\r\n\r\nvar readRole = await vaultClient.MySqlReadNamedRoleAsync(mySqlRole, mountPoint);\r\nvar roleSql = readRole.Data.Sql;\r\n```\r\n\r\n##### Generate MySql Credentials\r\n\r\n```cs\r\nvar mySqlCredentials = await vaultClient.MySqlGenerateDynamicCredentialsAsync(mySqlRole, backend.MountPoint);\r\n\r\nvar mySqlUsername = mySqlCredentials.Data.Username;\r\nvar mySqlPassword = mySqlCredentials.Data.Password;\r\n\r\n```\r\n#### PKI (Certificates) Secret Backend\r\n\r\n##### Configuring a PKI Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar mountpoint = \"pki\" + Guid.NewGuid();\r\nvar backend = new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.PKI,\r\n    MountPoint = mountpoint\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\n// write expiry\r\nvar expiry = \"124h\";\r\nvar commonName = \"blah.example.com\";\r\n\r\nawait vaultClient.PKIWriteCRLExpirationAsync(expiry, mountpoint);\r\n\r\nvar readExpiry = await vaultClient.PKIReadCRLExpirationAsync(mountpoint);\r\nAssert.Equal(expiry, readExpiry.Data.Expiry);\r\n\r\n// read certificate in various ways\r\nvar nocaCert = await vaultClient.PKIReadCACertificateAsync(CertificateFormat.pem, mountpoint);\r\nAssert.Null(nocaCert.CertificateContent);\r\n\r\n// generate root certificate\r\nvar rootCertificateWithoutPrivateKey =\r\n    await vaultClient.PKIGenerateRootCACertificateAsync(new RootCertificateRequestOptions\r\n    {\r\n        CommonName = commonName,\r\n        ExportPrivateKey = false\r\n    }, mountpoint);\r\n\r\nAssert.Null(rootCertificateWithoutPrivateKey.Data.PrivateKey);\r\n\r\nvar rootCertificate =\r\n    await vaultClient.PKIGenerateRootCACertificateAsync(new RootCertificateRequestOptions\r\n    {\r\n        CommonName = commonName,\r\n        ExportPrivateKey = true\r\n    }, mountpoint);\r\n\r\nAssert.NotNull(rootCertificate.Data.PrivateKey);\r\n\r\n// read certificate in various ways\r\nvar caCert = await vaultClient.PKIReadCACertificateAsync(CertificateFormat.pem, mountpoint);\r\nAssert.NotNull(caCert.CertificateContent);\r\n\r\nvar caReadCert = await vaultClient.PKIReadCertificateAsync(\"ca\", mountpoint);\r\nAssert.Equal(caCert.CertificateContent, caReadCert.Data.CertificateContent);\r\n\r\nvar caSerialNumberReadCert = await vaultClient.PKIReadCertificateAsync(rootCertificate.Data.SerialNumber, mountpoint);\r\nAssert.Equal(caCert.CertificateContent, caSerialNumberReadCert.Data.CertificateContent);\r\n\r\nvar crlCert = await vaultClient.PKIReadCertificateAsync(\"crl\", mountpoint);\r\nAssert.NotNull(crlCert.Data.CertificateContent);\r\n\r\nvar crlCert2 = await vaultClient.PKIReadCRLCertificateAsync(CertificateFormat.pem, mountpoint);\r\nAssert.NotNull(crlCert2.CertificateContent);\r\n\r\n// write and read certificate endpoints\r\n\r\nvar crlEndpoint = _vaultUri.AbsoluteUri + \"/v1/\" + mountpoint + \"/crl\";\r\nvar issuingEndpoint = _vaultUri.AbsoluteUri + \"/v1/\" + mountpoint + \"/ca\";\r\n\r\nvar endpoints = new CertificateEndpointOptions\r\n{\r\n    CRLDistributionPointEndpoints = string.Join(\",\", new List<string> { crlEndpoint }),\r\n    IssuingCertificateEndpoints = string.Join(\",\", new List<string> { issuingEndpoint }),\r\n};\r\n\r\nawait vaultClient.PKIWriteCertificateEndpointsAsync(endpoints, mountpoint);\r\n\r\nvar readEndpoints = await vaultClient.PKIReadCertificateEndpointsAsync(mountpoint);\r\n\r\nAssert.Equal(crlEndpoint, readEndpoints.Data.CRLDistributionPointEndpoints.First());\r\nAssert.Equal(issuingEndpoint, readEndpoints.Data.IssuingCertificateEndpoints.First());\r\n\r\n// rotate CRL\r\nvar rotate = await vaultClient.PKIRotateCRLAsync(mountpoint);\r\nAssert.True(rotate);\r\n\r\nawait vaultClient.RevokeSecretAsync(rootCertificateWithoutPrivateKey.LeaseId);\r\n```\r\n##### Write/Read PKI Role\r\n\r\n```cs\r\n// Create new Role\r\nvar roleName = Guid.NewGuid().ToString();\r\n\r\nvar role = new CertificateRoleDefinition\r\n{\r\n    AllowedDomains = \"example.com\",\r\n    AllowSubdomains = true,\r\n    MaximumTimeToLive = \"72h\",\r\n};\r\n\r\nawait vaultClient.PKIWriteNamedRoleAsync(roleName, role, mountpoint);\r\n\r\nvar readRole = await vaultClient.PKIReadNamedRoleAsync(roleName, mountpoint);\r\nAssert.Equal(role.AllowedDomains, readRole.Data.AllowedDomains);\r\n\r\n```\r\n\r\n##### Generate PKI Credentials\r\n\r\n```cs\r\nvar certificateCredentials =\r\n    await\r\n        vaultClient.PKIGenerateDynamicCredentialsAsync(roleName,\r\n            new CertificateCredentialsRequestOptions\r\n            {\r\n                CommonName = commonName,\r\n                CertificateFormat = CertificateFormat.pem\r\n            }, mountpoint);\r\n\r\nvar privateKey = certificateCredentials.Data.PrivateKey;\r\n\r\n```\r\n\r\n#### PostgreSql Secret Backend\r\n\r\n##### Configuring a PostgreSql Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar mountPoint = \"postgresql\" + Guid.NewGuid();\r\nvar backend = new SecretBackend\r\n{\r\n    MountPoint = mountPoint,\r\n    BackendType = SecretBackendType.PostgreSql,\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\nawait vaultClient.PostgreSqlConfigureCredentialLeaseSettingsAsync(new CredentialLeaseSettings()\r\n{\r\n    LeaseDuration = \"1h\",\r\n    MaximumLeaseDuration = \"2h\"\r\n}, mountPoint);\r\n\r\n// configure root connection info to create/manage roles and generate credentials\r\nawait vaultClient.PostgreSqlConfigureConnectionAsync(new PostgreSqlConnectionInfo\r\n{\r\n    ConnectionString = \"con_string\",\r\n    MaximumOpenConnections = 5\r\n}, mountPoint);\r\n\r\nvar sql = \"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\";\r\n\r\n// create a named role\r\nvar postgreSqlRole = \"postgresql-readonly-role\";\r\n\r\nawait vaultClient.PostgreSqlWriteNamedRoleAsync(postgreSqlRole, new PostgreSqlRoleDefinition()\r\n{\r\n    Sql = sql\r\n}, mountPoint);\r\n\r\nvar readRole = await vaultClient.PostgreSqlReadNamedRoleAsync(postgreSqlRole, mountPoint);\r\nAssert.Equal(sql, readRole.Data.Sql);\r\n```\r\n\r\n##### Generate PostgreSql Credentials\r\n\r\n```cs\r\nvar postgreSqlCredentials = await vaultClient.PostgreSqlGenerateDynamicCredentialsAsync(postgreSqlRole, backend.MountPoint);\r\n\r\nAssert.NotNull(postgreSqlCredentials.LeaseId);\r\nAssert.NotNull(postgreSqlCredentials.Data.Username);\r\nAssert.NotNull(postgreSqlCredentials.Data.Password);\r\n\r\n```\r\n#### RabbitMQ Secret Backend\r\n\r\n##### Configuring a RabbitMQ Backend\r\n\r\n```cs\r\n// mount the backend\r\nawait vaultClient.QuickMountSecretBackendAsync(SecretBackendType.RabbitMQ);\r\n\r\n// configure root connection info to create/manage roles and generate credentials\r\nvar connectionInfo = new RabbitMQConnectionInfo\r\n{\r\n    ConnectionUri = \"http://localhost:15672\",\r\n    Username = \"guest\",\r\n    Password = \"guest\",\r\n    VerifyConnection = true\r\n};\r\n\r\nawait vaultClient.RabbitMQConfigureConnectionAsync(connectionInfo);\r\n\r\nvar lease = new CredentialTimeToLiveSettings\r\n{\r\n    TimeToLive = \"1m1s\",\r\n    MaximumTimeToLive = \"2m1s\"\r\n};\r\n\r\nawait vaultClient.RabbitMQConfigureCredentialLeaseSettingsAsync(lease);\r\nvar queriedLease = await vaultClient.RabbitMQReadCredentialLeaseSettingsAsync();\r\n\r\nvar roleName = \"rabbitmqrole\";\r\n\r\nvar role = new RabbitMQRoleDefinition\r\n{\r\n    VirtualHostPermissions = \"{\\\"/\\\":{\\\"write\\\": \\\".*\\\", \\\"read\\\": \\\".*\\\"}}\"\r\n};\r\n\r\nawait vaultClient.RabbitMQWriteNamedRoleAsync(roleName, role);\r\n\r\nvar queriedRole = await vaultClient.RabbitMQReadNamedRoleAsync(roleName);\r\n```\r\n\r\n##### Generate RabbitMQ Credentials\r\n\r\n```cs\r\nvar generatedCreds = await vaultClient.RabbitMQGenerateDynamicCredentialsAsync(roleName);\r\n\r\nAssert.NotNull(generatedCreds.Data.Username);\r\nAssert.NotNull(generatedCreds.Data.Password);\r\n\r\n```\r\n\r\n#### SSH Secret Backend\r\n\r\n##### Configuring a SSH Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar sshKeyName = Guid.NewGuid().ToString();\r\nvar sshRoleName = Guid.NewGuid().ToString();\r\n\r\nvar mountPoint = \"ssh\" + Guid.NewGuid();\r\nvar backend = new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.SSH,\r\n    MountPoint = mountPoint,\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\n// configure key and role\r\nvar privateKey = @\"-----BEGIN RSA PRIVATE KEY----- key ---\";\r\n\r\nvar ip = \"127.0.0.1\";\r\nvar user = \"rajan\";\r\n\r\nawait vaultClient.SSHWriteNamedKeyAsync(sshKeyName, privateKey, mountPoint);\r\nawait vaultClient.SSHWriteNamedRoleAsync(sshRoleName, new SSHOTPRoleDefinition\r\n{\r\n    RoleDefaultUser = user,\r\n    CIDRValues = \"127.0.0.1/10\",\r\n}, mountPoint);\r\n\r\nvar role = await vaultClient.SSHReadNamedRoleAsync(sshRoleName, mountPoint);\r\nAssert.True(role.Data.KeyTypeToGenerate == SSHKeyType.otp);\r\n\r\n```\r\n\r\n##### Generate SSH Credentials\r\n\r\n```cs\r\nvar credentials = await\r\n    vaultClient.SSHGenerateDynamicCredentialsAsync(sshRoleName, ip,\r\n        sshBackendMountPoint: mountPoint);\r\n\r\nAssert.Equal(user, credentials.Data.Username);\r\n\r\n```\r\n#### Transit Secret Backend\r\n\r\n##### Configuring a Transit Backend\r\n\r\n```cs\r\n// mount the backend\r\nvar backend = new SecretBackend\r\n{\r\n    BackendType = SecretBackendType.Transit,\r\n    MountPoint = \"transit\" + Guid.NewGuid(),\r\n};\r\n\r\nawait vaultClient.MountSecretBackendAsync(backend);\r\n\r\n// create encryption key\r\nvar keyName = \"test_key\" + Guid.NewGuid();\r\nvar context = \"context1\";\r\n\r\nvar plainText = \"raja\";\r\nvar encodedPlainText = Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText));\r\n\r\nawait vaultClient.TransitCreateEncryptionKeyAsync(keyName, true, backend.MountPoint);\r\nvar keyInfo = await vaultClient.TransitGetEncryptionKeyInfoAsync(keyName, backend.MountPoint);\r\n\r\nAssert.Equal(keyName, keyInfo.Data.Name);\r\nAssert.True(keyInfo.Data.MustUseKeyDerivation);\r\nAssert.False(keyInfo.Data.IsDeletionAllowed);\r\n\r\n// configure the key\r\nawait vaultClient.TransitConfigureEncryptionKeyAsync(keyName, isDeletionAllowed: true, transitBackendMountPoint: backend.MountPoint);\r\n\r\nkeyInfo = await vaultClient.TransitGetEncryptionKeyInfoAsync(keyName, backend.MountPoint);\r\nAssert.True(keyInfo.Data.IsDeletionAllowed);\r\n\r\n```\r\n\r\n##### Encrypt/Decrypt text\r\n\r\n```cs\r\nvar cipherText = await vaultClient.TransitEncryptAsync(keyName, encodedPlainText, context, transitBackendMountPoint: backend.MountPoint);\r\n\r\nvar plainText2 = Encoding.UTF8.GetString(Convert.FromBase64String((await vaultClient.TransitDecryptAsync(keyName, cipherText.Data.CipherText, context, backend.MountPoint)).Data.PlainText));\r\n\r\nAssert.Equal(plainText, plainText2);\r\n```\r\n\r\n##### Other Transit Operations\r\n\r\n```cs\r\nawait vaultClient.TransitRotateEncryptionKeyAsync(keyName, backend.MountPoint);\r\nvar cipherText2 = await vaultClient.TransitEncryptAsync(keyName, encodedPlainText, context, transitBackendMountPoint: backend.MountPoint);\r\n\r\nAssert.NotEqual(cipherText.Data.CipherText, cipherText2.Data.CipherText);\r\n\r\nvar cipherText3 = await vaultClient.TransitRewrapWithLatestEncryptionKeyAsync(keyName, cipherText.Data.CipherText, context, backend.MountPoint);\r\n\r\nvar newKey1 = await vaultClient.TransitCreateDataKeyAsync(keyName, false, context, 128, backend.MountPoint);\r\nAssert.Null(newKey1.Data.PlainTextKey);\r\n\r\nnewKey1 = await vaultClient.TransitCreateDataKeyAsync(keyName, true, context, 128, backend.MountPoint);\r\nAssert.NotNull(newKey1.Data.PlainTextKey);\r\n\r\nawait vaultClient.TransitDeleteEncryptionKeyAsync(keyName, backend.MountPoint);\r\n\r\n```\r\n### Audit Backends (All of them are supported)\r\n\r\n* VaultSharp supports all the audit backends supported by the Vault Service 0.4.0\r\n* Here is a sample to instantiate the vault client with each of the audit backends.\r\n\r\n#### File Audit Backend\r\n\r\n```cs\r\n\r\nvar audits = (await vaultClient.GetAllEnabledAuditBackendsAsync()).ToList();\r\n\r\n// enable new file audit\r\nvar newFileAudit = new FileAuditBackend\r\n{\r\n    BackendType = AuditBackendType.File,\r\n    Description = \"store logs in a file - test cases\",\r\n    Options = new FileAuditBackendOptions\r\n    {\r\n        FilePath = \"/var/log/file\"\r\n    }\r\n};\r\n\r\nawait vaultClient.EnableAuditBackendAsync(newFileAudit);\r\n\r\n// get audits\r\nvar newAudits = (await vaultClient.GetAllEnabledAuditBackendsAsync()).ToList();\r\nAssert.Equal(audits.Count + 1, newAudits.Count);\r\n\r\n// hash with audit\r\nvar hash = await vaultClient.HashWithAuditBackendAsync(newFileAudit.MountPoint, \"testinput\");\r\nAssert.NotNull(hash);\r\n\r\n// disabled audit\r\nawait vaultClient.DisableAuditBackendAsync(newFileAudit.MountPoint);\r\n```\r\n\r\n#### Syslog Audit Backend\r\n\r\n```cs\r\n\r\n// enable new syslog audit\r\nvar newSyslogAudit = new SyslogAuditBackend\r\n{\r\n    BackendType = AuditBackendType.Syslog,\r\n    Description = \"syslog audit - test cases\",\r\n    Options = new SyslogAuditBackendOptions()\r\n};\r\n\r\nawait vaultClient.EnableAuditBackendAsync(newSyslogAudit);\r\n\r\n// get audits\r\nvar newAudits2 = (await vaultClient.GetAllEnabledAuditBackendsAsync()).ToList();\r\nAssert.Equal(1, newAudits2.Count);\r\n\r\n// disabled audit\r\nawait vaultClient.DisableAuditBackendAsync(newSyslogAudit.MountPoint);\r\n\r\n// get audits\r\nvar oldAudits2 = (await vaultClient.GetAllEnabledAuditBackendsAsync()).ToList();\r\nAssert.Equal(audits.Count, oldAudits2.Count);\r\n\r\n```\r\n\r\n### More Administrative & Other operations\r\n\r\n* VaultSharp supports all the operations supported by the Service.\r\n* These include administrative ones like Inititalize, Unseal, Seal etc.\r\n* Here are some samples.\r\n\r\n```cs\r\n\r\nawait noAuthInfoClient.InitializeAsync(5, 3, null);\r\nawait vaultClient.SealAsync();\r\n\r\nawait vaultClient.UnsealAsync(masterKey); // need to run this in a loop for all master keys\r\nawait vaultClient.UnsealQuickAsync(allMasterKeys);  // unseals the Vault in 1 shot.\r\n\r\nawait vaultClient.GetSealStatusAsync();\r\n\r\n// all policy operations\r\n\r\n// write a new policy\r\nvar newPolicy = new Policy\r\n{\r\n    Name = \"gubdu\",\r\n    Rules = \"path \\\"sys/*\\\" {  policy = \\\"deny\\\" }\"\r\n};\r\n\r\nawait vaultClient.WritePolicyAsync(newPolicy);\r\n\r\n// get new policy\r\nvar newPolicyGet = await vaultClient.GetPolicyAsync(newPolicy.Name);\r\nAssert.Equal(newPolicy.Rules, newPolicyGet.Rules);\r\n\r\n// write updates to a new policy\r\nnewPolicy.Rules = \"path \\\"sys/*\\\" {  policy = \\\"read\\\" }\";\r\n\r\nawait vaultClient.WritePolicyAsync(newPolicy);\r\n\r\n// get new policy\r\nnewPolicyGet = await vaultClient.GetPolicyAsync(newPolicy.Name);\r\nAssert.Equal(newPolicy.Rules, newPolicyGet.Rules);\r\n\r\n// delete policy\r\nawait vaultClient.DeletePolicyAsync(newPolicy.Name);\r\n\r\n```\r\n\r\n### Miscellaneous Features\r\n\r\n* VaultSharp supports some awesome features like quick mount, quick unseal, quick rekey etc.\r\n* It also supports setting Proxy settings, custom message handlers for the HttpClient.\r\n\r\n#### Quick mount, unseal and rekey methods\r\n\r\n```cs\r\n\r\n// quickly mount a secret backend\r\nawait vaultClient.QuickMountSecretBackendAsync(SecretBackendType.AWS);\r\n\r\n// quickly mount an auth backend\r\nawait vaultClient.QuickEnableAuthenticationBackendAsync(AuthenticationBackendType.GitHub);\r\n\r\n// quickly unseal Vault with a single call.\r\nvar sealStatus = await UnauthenticatedVaultClient.QuickUnsealAsync(AllMasterKeys);\r\n\r\n// quickly rekey Vault with a single call.\r\nvar quick = await UnauthenticatedVaultClient.QuickRekeyAsync(AllMasterKeys, rekeyStatus.Nonce);\r\n\r\n```\r\n#### Setting Proxy Settings, custom Message Handlers etc.\r\n\r\n```cs\r\n\r\nvar vaultClient = VaultClientFactory.CreateVaultClient(VaultUriWithPort, new TokenAuthenticationInfo(someToken), postHttpClientInitializeAction:\r\n    httpClient =>\r\n    {\r\n        // set proxy or custom handlers here.\r\n    });\r\n```\r\n\r\n### In Conclusion\r\n\r\n* If the above documentation doesn't help you, feel free to create an issue or email me. https://github.com/rajanadar/VaultSharp/issues/new\r\n* Also, the Intellisense on IVaultClient class should help. I have tried to add a lot of documentation.\r\n\r\nHappy Coding folks!\r\n\r\n",
  "google": "UA-72715364-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}