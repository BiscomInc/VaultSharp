<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>VaultSharp by rajanadar</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Vaultsharp</h1>
      <h2 class="project-tagline">A .NET Library for HashiCorp&#39;s Vault - A Secret Management System.</h2>
      <a href="https://github.com/rajanadar/VaultSharp" class="btn">View on GitHub</a>
      <a href="https://github.com/rajanadar/VaultSharp/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/rajanadar/VaultSharp/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="vaultsharp" class="anchor" href="#vaultsharp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>VaultSharp</h1>

<p>A .NET Library for HashiCorp's Vault - A Secret Management System.</p>

<h2>
<a id="nuget-package-httpswwwnugetorgpackagesvaultsharp" class="anchor" href="#nuget-package-httpswwwnugetorgpackagesvaultsharp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Nuget Package: <a href="https://www.nuget.org/packages/VaultSharp/">https://www.nuget.org/packages/VaultSharp/</a>
</h2>

<h2>
<a id="github-site-httpsgithubcomrajanadarvaultsharp" class="anchor" href="#github-site-httpsgithubcomrajanadarvaultsharp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GitHub Site: <a href="https://github.com/rajanadar/VaultSharp">https://github.com/rajanadar/VaultSharp</a>
</h2>

<h4>
<a id="report-feedbackissues-here-httpsgithubcomrajanadarvaultsharpissuesnew" class="anchor" href="#report-feedbackissues-here-httpsgithubcomrajanadarvaultsharpissuesnew" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Report Feedback/Issues Here: <a href="https://github.com/rajanadar/VaultSharp/issues/new">https://github.com/rajanadar/VaultSharp/issues/new</a>
</h4>

<p><strong>Table of Contents</strong></p>

<ul>
<li>
<a href="#vaultsharp">VaultSharp</a>

<ul>
<li><a href="#nuget-package-httpswwwnugetorgpackagesvaultsharp">Nuget Package: https://www.nuget.org/packages/VaultSharp/</a></li>
<li>
<a href="#github-site-httpsgithubcomrajanadarvaultsharp">GitHub Site: https://github.com/rajanadar/VaultSharp</a>

<ul>
<li><a href="#what-is-vaultsharp">What is VaultSharp?</a></li>
<li><a href="#vaultsharp-04x-should-completely-support-vault-service-040">VaultSharp 0.4.x should completely support Vault Service 0.4.0</a></li>
<li><a href="#what-is-the-deal-with-the-versioning-of-vaultsharp-y-u-no-100">What is the deal with the Versioning of VaultSharp? (Y U NO 1.0.0)</a></li>
<li><a href="#how-do-i-use-vaultsharp-give-me-a-code-example">How do I use VaultSharp? Give me a code example</a></li>
<li><a href="#does-vaultsharp-support-all-the-authentication-secret-and-audit-backends">Does VaultSharp support all the Authentication, Secret and Audit Backends?</a></li>
<li><a href="#vaultsharp-and-100-consul-support">VaultSharp and 100% Consul Support</a></li>
<li><a href="#the-fundamental-read-and-write-operations-on-a-vault">The fundamental READ and WRITE operations on a Vault</a></li>
<li><a href="#can-i-use-it-in-my-powershell-automation">Can I use it in my PowerShell Automation?</a></li>
<li><a href="#all-the-methods-are-async-how-do-i-use-them-synchronously">All the methods are async. How do I use them synchronously?</a></li>
<li>
<a href="#authentication-backends-all-of-them-are-supported">Authentication Backends (All of them are supported)</a>

<ul>
<li><a href="#app-id-authentication-backend">App Id Authentication Backend</a></li>
<li><a href="#github-authentication-backend">GitHub Authentication Backend</a></li>
<li><a href="#ldap-authentication-backend">LDAP Authentication Backend</a></li>
<li><a href="#certificate-tls-authentication-backend">Certificate (TLS) Authentication Backend</a></li>
<li><a href="#token-authentication-backend">Token Authentication Backend</a></li>
<li><a href="#username-and-password-authentication-backend">Username and Password Authentication Backend</a></li>
</ul>
</li>
<li>
<a href="#secret-backends-all-of-them-are-supported">Secret Backends (All of them are supported)</a>

<ul>
<li>
<a href="#aws-secret-backend">AWS Secret Backend</a>

<ul>
<li><a href="#configuring-an-aws-backend">Configuring an AWS Backend</a></li>
<li><a href="#generate-aws-credentials">Generate AWS Credentials</a></li>
</ul>
</li>
<li>
<a href="#cassandra-secret-backend">Cassandra Secret Backend</a>

<ul>
<li><a href="#configuring-a-cassandra-backend">Configuring a Cassandra Backend</a></li>
<li><a href="#generate-cassandra-credentials">Generate Cassandra Credentials</a></li>
</ul>
</li>
<li>
<a href="#consul-secret-backend">Consul Secret Backend</a>

<ul>
<li><a href="#configuring-a-consul-backend">Configuring a Consul Backend</a></li>
<li><a href="#generate-consul-credentials">Generate Consul Credentials</a></li>
<li><a href="#deleting-role-and-unmounting-the-consul-backend">Deleting Role and Unmounting the Consul backend</a></li>
</ul>
</li>
<li><a href="#cubbyhole-secret-backend">Cubbyhole Secret Backend</a></li>
<li><a href="#generic-secret-backend">Generic Secret Backend</a></li>
<li>
<a href="#mysql-secret-backend">MySql Secret Backend</a>

<ul>
<li><a href="#configuring-a-mysql-backend">Configuring a MySql Backend</a></li>
<li><a href="#generate-mysql-credentials">Generate MySql Credentials</a></li>
</ul>
</li>
<li>
<a href="#pki-certificates-secret-backend">PKI (Certificates) Secret Backend</a>

<ul>
<li><a href="#configuring-a-pki-backend">Configuring a PKI Backend</a></li>
<li><a href="#writeread-pki-role">Write/Read PKI Role</a></li>
<li><a href="#generate-pki-credentials">Generate PKI Credentials</a></li>
</ul>
</li>
<li>
<a href="#postgresql-secret-backend">PostgreSql Secret Backend</a>

<ul>
<li><a href="#configuring-a-postgresql-backend">Configuring a PostgreSql Backend</a></li>
<li><a href="#generate-postgresql-credentials">Generate PostgreSql Credentials</a></li>
</ul>
</li>
<li>
<a href="#ssh-secret-backend">SSH Secret Backend</a>

<ul>
<li><a href="#configuring-a-ssh-backend">Configuring a SSH Backend</a></li>
<li><a href="#generate-ssh-credentials">Generate SSH Credentials</a></li>
</ul>
</li>
<li>
<a href="#transit-secret-backend">Transit Secret Backend</a>

<ul>
<li><a href="#configuring-a-transit-backend">Configuring a Transit Backend</a></li>
<li><a href="#encryptdecrypt-text">Encrypt/Decrypt text</a></li>
<li><a href="#other-transit-operations">Other Transit Operations</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#audit-backends-all-of-them-are-supported">Audit Backends (All of them are supported)</a>

<ul>
<li><a href="#file-audit-backend">File Audit Backend</a></li>
<li><a href="#syslog-audit-backend">Syslog Audit Backend</a></li>
</ul>
</li>
<li><a href="#more-administrative--other-operations">More Administrative &amp; Other operations</a></li>
<li><a href="#in-conclusion">In Conclusion</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<h3>
<a id="what-is-vaultsharp" class="anchor" href="#what-is-vaultsharp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is VaultSharp?</h3>

<ul>
<li>VaultSharp is a C# Library that can be used in any .NET application to interact with Hashicorp's Vault Service.</li>
<li>The Vault system is a secret management system built as an Http Service by Hashicorp. </li>
<li>This library supports all the Vault Service Apis documented here: <a href="https://www.vaultproject.io/docs/http/">https://www.vaultproject.io/docs/http/</a>
</li>
</ul>

<h3>
<a id="vaultsharp-04x-should-completely-support-vault-service-040" class="anchor" href="#vaultsharp-04x-should-completely-support-vault-service-040" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>VaultSharp 0.4.x should completely support Vault Service 0.4.0</h3>

<h3>
<a id="what-is-the-deal-with-the-versioning-of-vaultsharp-y-u-no-100" class="anchor" href="#what-is-the-deal-with-the-versioning-of-vaultsharp-y-u-no-100" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is the deal with the Versioning of VaultSharp? (Y U NO 1.0.0)</h3>

<ul>
<li>This library is written for the Vault Service version 0.4.0</li>
<li>The Vault service is evolving constantly and the Hashicorp team is rapidly working on it.</li>
<li>Pretty soon, we should have an 1.0.0 version of the Vault Service from Hashicorp.</li>
<li>Because this client library is intended to facilititate the Vault Service operations, this library makes it easier for its consumers to relate to the Vault service it supports.</li>
<li>Hence a version of 0.4.x denotes that this library will completely support the Vault 0.4.x Service Apis.</li>
<li>Tomorrow when Vault Service gets upgraded to 0.5.x, this library will be modified accordingly and versioned as 0.5.x</li>
</ul>

<h3>
<a id="how-do-i-use-vaultsharp-give-me-a-code-example" class="anchor" href="#how-do-i-use-vaultsharp-give-me-a-code-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How do I use VaultSharp? Give me a code example</h3>

<ul>
<li>Add a Nuget reference from here: <a href="https://www.nuget.org/packages/VaultSharp/">https://www.nuget.org/packages/VaultSharp/</a>
</li>
<li>Instantiate a IVaultClient as follows:</li>
</ul>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// instantiate VaultClient with one of the various authentication options available.</span>
IVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, authenticationInfo);

<span class="pl-c">// use it for operations.</span>
<span class="pl-k">var</span> consulCredentials = <span class="pl-k">await</span> vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRoleName, consulMountPoint);
<span class="pl-k">var</span> consulToken = consulCredentials.Data.Token;</pre></div>

<h3>
<a id="does-vaultsharp-support-all-the-authentication-secret-and-audit-backends" class="anchor" href="#does-vaultsharp-support-all-the-authentication-secret-and-audit-backends" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Does VaultSharp support all the Authentication, Secret and Audit Backends?</h3>

<ul>
<li>YES</li>
<li>All Authentication, Secret and Audit backends are supported by this library.</li>
<li>All administrative (seal, unseal, write policy), end-user (generate credentials) and unauthenticated methods (get status, get root CA) are supported by this client.</li>
</ul>

<h3>
<a id="vaultsharp-and-100-consul-support" class="anchor" href="#vaultsharp-and-100-consul-support" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>VaultSharp and 100% Consul Support</h3>

<ul>
<li>VaultSharp supports all the secret backends supported by the Vault 0.4.0 Service.</li>
<li>This includes 100% support for a Consul Secret backend, which is the recommended secret backend for Vault.</li>
<li>Please look at the API usage in the 'Consul' section of 'Secret Backends' below, to see all the Consul related methods in action.</li>
</ul>

<h3>
<a id="the-fundamental-read-and-write-operations-on-a-vault" class="anchor" href="#the-fundamental-read-and-write-operations-on-a-vault" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The fundamental READ and WRITE operations on a Vault</h3>

<ul>
<li>The generic READ/WRITE Apis of vault allow you to do a variety of operations.</li>
<li>A lot or almost all of these operations are supported in a strongly typed manner with dedicated methods for them in this library.</li>
<li>However, for some reason, if you want to use the generic READ and WRITE methods of Vault, you can use them as follows:</li>
</ul>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> path = <span class="pl-s"><span class="pl-pds">"</span>cubbyhole/foo/test<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> secretData = <span class="pl-k">new</span> Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;
{
    {<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>},
    {<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>},
    {<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>, <span class="pl-c1">false</span>},
};

<span class="pl-k">await</span> vaultClient.WriteSecretAsync(path, secretData);

<span class="pl-k">var</span> secret = <span class="pl-k">await</span> vaultClient.ReadSecretAsync(path);
<span class="pl-k">var</span> data = secret.Data; <span class="pl-c">// this is the original dictionary back.</span></pre></div>

<h3>
<a id="can-i-use-it-in-my-powershell-automation" class="anchor" href="#can-i-use-it-in-my-powershell-automation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Can I use it in my PowerShell Automation?</h3>

<ul>
<li>Absolutely. VaultSharp is a .NET Library. </li>
<li>This means, apart from using it in your C#, VB.NET, J#.NET and any .NET application, you can use it in PowerShell automation as well.</li>
<li>Load up the DLL in your PowerShell code and execute the methods. PowerShell can totally work with .NET Dlls.</li>
</ul>

<h3>
<a id="all-the-methods-are-async-how-do-i-use-them-synchronously" class="anchor" href="#all-the-methods-are-async-how-do-i-use-them-synchronously" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>All the methods are async. How do I use them synchronously?</h3>

<ul>
<li>The methods are async as the defacto implementation. The recommended usage.</li>
<li>However, there are innumerable scenarios where you would continue to want to use it synchronously.</li>
<li>For all those cases, there are various options available to you.</li>
<li>There is a lot of discussion around the right usage, avoiding deadlocks etc.</li>
<li>This library allows you to set the 'continueAsyncTasksOnCapturedContext' option when you initialize the client.</li>
<li>It is an optional parameter and defaults to 'false'</li>
<li>Setting it to false, allows you to access the .Result property of the task with reduced/zero deadlock issues.</li>
<li>There are other ways as well to invoke it synchronously, and  I leave it to you guys. (Task.Run etc.) </li>
<li>But please note that as much as possible, use it in an async manner. </li>
</ul>

<div class="highlight highlight-source-cs"><pre>
IVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, authenticationInfo, continueAsyncTasksOnCapturedContext: <span class="pl-c1">true</span>);

<span class="pl-k">var</span> consulSecret = vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRole).Result;
</pre></div>

<h3>
<a id="authentication-backends-all-of-them-are-supported" class="anchor" href="#authentication-backends-all-of-them-are-supported" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authentication Backends (All of them are supported)</h3>

<ul>
<li>VaultSharp supports all the authentication backends supported by the Vault Service 0.4.0</li>
<li>Here is a sample to instantiate the vault client with each of the authentication backends.</li>
</ul>

<h4>
<a id="app-id-authentication-backend" class="anchor" href="#app-id-authentication-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>App Id Authentication Backend</h4>

<div class="highlight highlight-source-cs"><pre>IAuthenticationInfo appIdAuthenticationInfo = <span class="pl-k">new</span> AppIdAuthenticationInfo(mountPoint, appId, userId);
IVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, appIdAuthenticationInfo);

<span class="pl-c">// any operations done using the vaultClient will use the vault token/policies mapped to the app id and user id.</span>
</pre></div>

<h4>
<a id="github-authentication-backend" class="anchor" href="#github-authentication-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GitHub Authentication Backend</h4>

<div class="highlight highlight-source-cs"><pre>IAuthenticationInfo gitHubAuthenticationInfo = <span class="pl-k">new</span> GitHubAuthenticationInfo(mountPoint, personalAccessToken);
IVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, gitHubAuthenticationInfo);

<span class="pl-c">// any operations done using the vaultClient will use the vault token/policies mapped to the github token.</span>
</pre></div>

<h4>
<a id="ldap-authentication-backend" class="anchor" href="#ldap-authentication-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LDAP Authentication Backend</h4>

<div class="highlight highlight-source-cs"><pre>IAuthenticationInfo ldapAuthenticationInfo = <span class="pl-k">new</span> LDAPAuthenticationInfo(mountPoint, username, password);
IVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, ldapAuthenticationInfo);

<span class="pl-c">// any operations done using the vaultClient will use the vault token/policies mapped to the LDAP username and password.</span>
</pre></div>

<h4>
<a id="certificate-tls-authentication-backend" class="anchor" href="#certificate-tls-authentication-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Certificate (TLS) Authentication Backend</h4>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> clientCertificate = <span class="pl-k">new</span> X509Certificate2(certificatePath, certificatePassword, X509KeyStorageFlags.Exportable | X509KeyStorageFlags.PersistKeySet);

IAuthenticationInfo certificateAuthenticationInfo = <span class="pl-k">new</span> CertificateAuthenticationInfo(mountPoint, clientCertificate);
IVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, certificateAuthenticationInfo);

<span class="pl-c">// any operations done using the vaultClient will use the vault token/policies mapped to the client certificate.</span>
</pre></div>

<h4>
<a id="token-authentication-backend" class="anchor" href="#token-authentication-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Token Authentication Backend</h4>

<div class="highlight highlight-source-cs"><pre>IAuthenticationInfo tokenAuthenticationInfo = <span class="pl-k">new</span> TokenAuthenticationInfo(mountPoint, vaultToken);
IVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, tokenAuthenticationInfo);

<span class="pl-c">// any operations done using the vaultClient will use the vault token/policies mapped to the vault token.</span>
</pre></div>

<h4>
<a id="username-and-password-authentication-backend" class="anchor" href="#username-and-password-authentication-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Username and Password Authentication Backend</h4>

<div class="highlight highlight-source-cs"><pre>IAuthenticationInfo usernamePasswordAuthenticationInfo = <span class="pl-k">new</span> UsernamePasswordAuthenticationInfo(mountPoint, username, password);
IVaultClient vaultClient = VaultClientFactory.CreateVaultClient(vaultUriWithPort, usernamePasswordAuthenticationInfo);

<span class="pl-c">// any operations done using the vaultClient will use the vault token/policies mapped to the username/password.</span>
</pre></div>

<h3>
<a id="secret-backends-all-of-them-are-supported" class="anchor" href="#secret-backends-all-of-them-are-supported" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Secret Backends (All of them are supported)</h3>

<ul>
<li>VaultSharp supports all the secret backends supported by the Vault Service 0.4.0</li>
<li>Here is a sample to instantiate the vault client with each of the secret backends.</li>
</ul>

<h4>
<a id="aws-secret-backend" class="anchor" href="#aws-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AWS Secret Backend</h4>

<h5>
<a id="configuring-an-aws-backend" class="anchor" href="#configuring-an-aws-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuring an AWS Backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// mount the backend</span>
<span class="pl-k">await</span> vaultClient.MountSecretBackendAsync(<span class="pl-k">new</span> SecretBackend
{
    BackendType = SecretBackendType.AWS
});

<span class="pl-c">// configure root credentials to create/manage roles and generate credentials</span>
<span class="pl-k">await</span> vaultClient.AWSConfigureRootCredentialsAsync(<span class="pl-k">new</span> AWSRootCredentials
{
    AccessKey = <span class="pl-s"><span class="pl-pds">"</span>access-key<span class="pl-pds">"</span></span>,
    SecretKey = <span class="pl-s"><span class="pl-pds">"</span>secret-key<span class="pl-pds">"</span></span>,
    Region = <span class="pl-s"><span class="pl-pds">"</span>region<span class="pl-pds">"</span></span>
});

<span class="pl-c">// create a named role with the IAM policy</span>
<span class="pl-k">await</span> vaultClient.AWSWriteNamedRoleAsync(<span class="pl-s"><span class="pl-pds">"</span>myAwsRole<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> AWSRoleDefinition
{
    Policy = <span class="pl-s"><span class="pl-pds">"</span>iam-policy-contents<span class="pl-pds">"</span></span>
});</pre></div>

<h5>
<a id="generate-aws-credentials" class="anchor" href="#generate-aws-credentials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generate AWS Credentials</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> awsCredentials = <span class="pl-k">await</span> vaultClient.AWSGenerateDynamicCredentialsAsync(<span class="pl-s"><span class="pl-pds">"</span>myAwsRole<span class="pl-pds">"</span></span>);
<span class="pl-k">var</span> awsAccessKey = awsCredentials.Data.AccessKey;
<span class="pl-k">var</span> awsSecretKey = awsCredentials.Data.SecretKey;
</pre></div>

<h4>
<a id="cassandra-secret-backend" class="anchor" href="#cassandra-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cassandra Secret Backend</h4>

<h5>
<a id="configuring-a-cassandra-backend" class="anchor" href="#configuring-a-cassandra-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuring a Cassandra Backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// mount the backend</span>
<span class="pl-k">await</span> vaultClient.MountSecretBackendAsync(<span class="pl-k">new</span> SecretBackend
{
    BackendType = SecretBackendType.Cassandra
});

<span class="pl-c">// configure root connection info to create/manage roles and generate credentials</span>
<span class="pl-k">await</span> vaultClient.CassandraConfigureConnectionAsync(<span class="pl-k">new</span> CassandraConnectionInfo
{
    Hosts = <span class="pl-s"><span class="pl-pds">"</span>hosts<span class="pl-pds">"</span></span>,
    Username = <span class="pl-s"><span class="pl-pds">"</span>username<span class="pl-pds">"</span></span>,
    Password = <span class="pl-s"><span class="pl-pds">"</span>password<span class="pl-pds">"</span></span>
});

<span class="pl-c">// create a named role</span>
<span class="pl-k">await</span> vaultClient.CassandraWriteNamedRoleAsync(<span class="pl-s"><span class="pl-pds">"</span>myCassandraRole<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> CassandraRoleDefinition
{
    CreationCql = <span class="pl-s"><span class="pl-pds">"</span>csql<span class="pl-pds">"</span></span>
});</pre></div>

<h5>
<a id="generate-cassandra-credentials" class="anchor" href="#generate-cassandra-credentials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generate Cassandra Credentials</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> cassandraCredentials = <span class="pl-k">await</span> vaultClient.CassandraGenerateDynamicCredentialsAsync(<span class="pl-s"><span class="pl-pds">"</span>myCassandraRole<span class="pl-pds">"</span></span>);
<span class="pl-k">var</span> cassandraUsername = cassandraCredentials.Data.Username;
<span class="pl-k">var</span> cassandraPassword = cassandraCredentials.Data.Password;
</pre></div>

<h4>
<a id="consul-secret-backend" class="anchor" href="#consul-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Consul Secret Backend</h4>

<h5>
<a id="configuring-a-consul-backend" class="anchor" href="#configuring-a-consul-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuring a Consul Backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// mount the backend</span>
<span class="pl-k">var</span> consulAddress = <span class="pl-s"><span class="pl-pds">"</span>127.0.0.1:8500<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> consulAclMasterToken = <span class="pl-s"><span class="pl-pds">"</span>raja<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> backend = <span class="pl-k">new</span> SecretBackend
{
    BackendType = SecretBackendType.Consul,
};

<span class="pl-k">await</span> vaultClient.MountSecretBackendAsync(backend);

<span class="pl-c">// configure access to Consul and create roles</span>
<span class="pl-k">var</span> consulRole = <span class="pl-s"><span class="pl-pds">"</span>consulRole<span class="pl-pds">"</span></span>;

<span class="pl-k">await</span> vaultClient.ConsulConfigureAccessAsync(<span class="pl-k">new</span> ConsulAccessInfo()
{
    AddressWithPort = consulAddress,
    ManagementToken = consulAclMasterToken
});

<span class="pl-c">// create a named role</span>
<span class="pl-k">await</span> vaultClient.ConsulWriteNamedRoleAsync(consulRole, <span class="pl-k">new</span> ConsulRoleDefinition()
{
    TokenType = ConsulTokenType.management,
});

<span class="pl-k">var</span> readRole = <span class="pl-k">await</span> vaultClient.ConsulReadNamedRoleAsync(consulRole);
Assert.Equal(ConsulTokenType.management, readRole.Data.TokenType);</pre></div>

<h5>
<a id="generate-consul-credentials" class="anchor" href="#generate-consul-credentials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generate Consul Credentials</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> consulCredentials = <span class="pl-k">await</span> vaultClient.ConsulGenerateDynamicCredentialsAsync(consulRole);
<span class="pl-k">var</span> consulToken = consulCredentials.Data.Token;</pre></div>

<h5>
<a id="deleting-role-and-unmounting-the-consul-backend" class="anchor" href="#deleting-role-and-unmounting-the-consul-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Deleting Role and Unmounting the Consul backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">await</span> vaultClient.ConsulDeleteNamedRoleAsync(consulRole);
<span class="pl-k">await</span> vaultClient.UnmountSecretBackendAsync(SecretBackendType.Consul.Type);
</pre></div>

<h4>
<a id="cubbyhole-secret-backend" class="anchor" href="#cubbyhole-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cubbyhole Secret Backend</h4>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> path = <span class="pl-s"><span class="pl-pds">"</span>cubbyhole/foo1/foo2<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> values = <span class="pl-k">new</span> Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;
{
    {<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>},
    {<span class="pl-s"><span class="pl-pds">"</span>foo2<span class="pl-pds">"</span></span>, <span class="pl-c1">345</span> }
};

<span class="pl-k">await</span> vaultClient.CubbyholeWriteSecretAsync(path, values);

<span class="pl-k">var</span> readValues = <span class="pl-k">await</span> vaultClient.CubbyholeReadSecretAsync(path);
<span class="pl-k">var</span> data = readValues.Data; <span class="pl-c">// gives back the dictionary</span>

<span class="pl-k">await</span> vaultClient.CubbyholeDeleteSecretAsync(path);
</pre></div>

<h4>
<a id="generic-secret-backend" class="anchor" href="#generic-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generic Secret Backend</h4>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> mountpoint = <span class="pl-s"><span class="pl-pds">"</span>secret<span class="pl-pds">"</span></span> + Guid.NewGuid();

<span class="pl-k">var</span> path = mountpoint + <span class="pl-s"><span class="pl-pds">"</span>/foo1/blah2<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> values = <span class="pl-k">new</span> Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;
{
    {<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>},
    {<span class="pl-s"><span class="pl-pds">"</span>foo2<span class="pl-pds">"</span></span>, <span class="pl-c1">345</span> }
};

<span class="pl-k">await</span>
    vaultClient.MountSecretBackendAsync(<span class="pl-k">new</span> SecretBackend()
    {
        BackendType = SecretBackendType.Generic,
        MountPoint = mountpoint
    });

<span class="pl-k">await</span> vaultClient.GenericWriteSecretAsync(path, values);

<span class="pl-k">var</span> readValues = <span class="pl-k">await</span> vaultClient.GenericReadSecretAsync(path);
<span class="pl-k">var</span> data = readValues.Data; <span class="pl-c">// gives back the dictionary</span>

<span class="pl-k">await</span> vaultClient.GenericDeleteSecretAsync(path);
</pre></div>

<h4>
<a id="mysql-secret-backend" class="anchor" href="#mysql-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MySql Secret Backend</h4>

<h5>
<a id="configuring-a-mysql-backend" class="anchor" href="#configuring-a-mysql-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuring a MySql Backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// mount the backend</span>
<span class="pl-k">var</span> mountPoint = <span class="pl-s"><span class="pl-pds">"</span>mysql<span class="pl-pds">"</span></span> + Guid.NewGuid();
<span class="pl-k">var</span> backend = <span class="pl-k">new</span> SecretBackend
{
    MountPoint = mountPoint,
    BackendType = SecretBackendType.MySql,
};

<span class="pl-k">await</span> vaultClient.MountSecretBackendAsync(backend);

<span class="pl-c">// configure root connection info to create/manage roles and generate credentials</span>
<span class="pl-k">await</span> vaultClient.MySqlConfigureConnectionAsync(<span class="pl-k">new</span> MySqlConnectionInfo()
{
    DataSourceName = <span class="pl-s"><span class="pl-pds">"</span>root:root@tcp(127.0.0.1:3306)/<span class="pl-pds">"</span></span>
}, mountPoint);

<span class="pl-k">var</span> sql = <span class="pl-s"><span class="pl-pds">"</span>CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT SELECT ON *.* TO '{{name}}'@'%';<span class="pl-pds">"</span></span>;

<span class="pl-k">await</span> vaultClient.MySqlConfigureCredentialLeaseSettingsAsync(<span class="pl-k">new</span> CredentialLeaseSettings()
{
    LeaseDuration = <span class="pl-s"><span class="pl-pds">"</span>1h<span class="pl-pds">"</span></span>,
    MaximumLeaseDuration = <span class="pl-s"><span class="pl-pds">"</span>2h<span class="pl-pds">"</span></span>
}, mountPoint);

<span class="pl-c">// create a named role</span>
<span class="pl-k">var</span> mySqlRole = <span class="pl-s"><span class="pl-pds">"</span>mysql-readonly-role<span class="pl-pds">"</span></span>;

<span class="pl-k">await</span> vaultClient.MySqlWriteNamedRoleAsync(mySqlRole, <span class="pl-k">new</span> MySqlRoleDefinition()
{
    Sql = sql
}, mountPoint);

<span class="pl-k">var</span> readRole = <span class="pl-k">await</span> vaultClient.MySqlReadNamedRoleAsync(mySqlRole, mountPoint);
<span class="pl-k">var</span> roleSql = readRole.Data.Sql;</pre></div>

<h5>
<a id="generate-mysql-credentials" class="anchor" href="#generate-mysql-credentials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generate MySql Credentials</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> mySqlCredentials = <span class="pl-k">await</span> vaultClient.MySqlGenerateDynamicCredentialsAsync(mySqlRole, backend.MountPoint);

<span class="pl-k">var</span> mySqlUsername = mySqlCredentials.Data.Username;
<span class="pl-k">var</span> mySqlPassword = mySqlCredentials.Data.Password;
</pre></div>

<h4>
<a id="pki-certificates-secret-backend" class="anchor" href="#pki-certificates-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PKI (Certificates) Secret Backend</h4>

<h5>
<a id="configuring-a-pki-backend" class="anchor" href="#configuring-a-pki-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuring a PKI Backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// mount the backend</span>
<span class="pl-k">var</span> mountpoint = <span class="pl-s"><span class="pl-pds">"</span>pki<span class="pl-pds">"</span></span> + Guid.NewGuid();
<span class="pl-k">var</span> backend = <span class="pl-k">new</span> SecretBackend
{
    BackendType = SecretBackendType.PKI,
    MountPoint = mountpoint
};

<span class="pl-k">await</span> vaultClient.MountSecretBackendAsync(backend);

<span class="pl-c">// write expiry</span>
<span class="pl-k">var</span> expiry = <span class="pl-s"><span class="pl-pds">"</span>124h<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> commonName = <span class="pl-s"><span class="pl-pds">"</span>blah.example.com<span class="pl-pds">"</span></span>;

<span class="pl-k">await</span> vaultClient.PKIWriteCRLExpirationAsync(expiry, mountpoint);

<span class="pl-k">var</span> readExpiry = <span class="pl-k">await</span> vaultClient.PKIReadCRLExpirationAsync(mountpoint);
Assert.Equal(expiry, readExpiry.Data.Expiry);

<span class="pl-c">// read certificate in various ways</span>
<span class="pl-k">var</span> nocaCert = <span class="pl-k">await</span> vaultClient.PKIReadCACertificateAsync(CertificateFormat.pem, mountpoint);
Assert.Null(nocaCert.CertificateContent);

<span class="pl-c">// generate root certificate</span>
<span class="pl-k">var</span> rootCertificateWithoutPrivateKey =
    <span class="pl-k">await</span> vaultClient.PKIGenerateRootCACertificateAsync(<span class="pl-k">new</span> RootCertificateRequestOptions
    {
        CommonName = commonName,
        ExportPrivateKey = <span class="pl-c1">false</span>
    }, mountpoint);

Assert.Null(rootCertificateWithoutPrivateKey.Data.PrivateKey);

<span class="pl-k">var</span> rootCertificate =
    <span class="pl-k">await</span> vaultClient.PKIGenerateRootCACertificateAsync(<span class="pl-k">new</span> RootCertificateRequestOptions
    {
        CommonName = commonName,
        ExportPrivateKey = <span class="pl-c1">true</span>
    }, mountpoint);

Assert.NotNull(rootCertificate.Data.PrivateKey);

<span class="pl-c">// read certificate in various ways</span>
<span class="pl-k">var</span> caCert = <span class="pl-k">await</span> vaultClient.PKIReadCACertificateAsync(CertificateFormat.pem, mountpoint);
Assert.NotNull(caCert.CertificateContent);

<span class="pl-k">var</span> caReadCert = <span class="pl-k">await</span> vaultClient.PKIReadCertificateAsync(<span class="pl-s"><span class="pl-pds">"</span>ca<span class="pl-pds">"</span></span>, mountpoint);
Assert.Equal(caCert.CertificateContent, caReadCert.Data.CertificateContent);

<span class="pl-k">var</span> caSerialNumberReadCert = <span class="pl-k">await</span> vaultClient.PKIReadCertificateAsync(rootCertificate.Data.SerialNumber, mountpoint);
Assert.Equal(caCert.CertificateContent, caSerialNumberReadCert.Data.CertificateContent);

<span class="pl-k">var</span> crlCert = <span class="pl-k">await</span> vaultClient.PKIReadCertificateAsync(<span class="pl-s"><span class="pl-pds">"</span>crl<span class="pl-pds">"</span></span>, mountpoint);
Assert.NotNull(crlCert.Data.CertificateContent);

<span class="pl-k">var</span> crlCert2 = <span class="pl-k">await</span> vaultClient.PKIReadCRLCertificateAsync(CertificateFormat.pem, mountpoint);
Assert.NotNull(crlCert2.CertificateContent);

<span class="pl-c">// write and read certificate endpoints</span>

<span class="pl-k">var</span> crlEndpoint = _vaultUri.AbsoluteUri + <span class="pl-s"><span class="pl-pds">"</span>/v1/<span class="pl-pds">"</span></span> + mountpoint + <span class="pl-s"><span class="pl-pds">"</span>/crl<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> issuingEndpoint = _vaultUri.AbsoluteUri + <span class="pl-s"><span class="pl-pds">"</span>/v1/<span class="pl-pds">"</span></span> + mountpoint + <span class="pl-s"><span class="pl-pds">"</span>/ca<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> endpoints = <span class="pl-k">new</span> CertificateEndpointOptions
{
    CRLDistributionPointEndpoints = <span class="pl-k">string</span>.Join(<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> List&lt;<span class="pl-k">string</span>&gt; { crlEndpoint }),
    IssuingCertificateEndpoints = <span class="pl-k">string</span>.Join(<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> List&lt;<span class="pl-k">string</span>&gt; { issuingEndpoint }),
};

<span class="pl-k">await</span> vaultClient.PKIWriteCertificateEndpointsAsync(endpoints, mountpoint);

<span class="pl-k">var</span> readEndpoints = <span class="pl-k">await</span> vaultClient.PKIReadCertificateEndpointsAsync(mountpoint);

Assert.Equal(crlEndpoint, readEndpoints.Data.CRLDistributionPointEndpoints.First());
Assert.Equal(issuingEndpoint, readEndpoints.Data.IssuingCertificateEndpoints.First());

<span class="pl-c">// rotate CRL</span>
<span class="pl-k">var</span> rotate = <span class="pl-k">await</span> vaultClient.PKIRotateCRLAsync(mountpoint);
Assert.True(rotate);

<span class="pl-k">await</span> vaultClient.RevokeSecretAsync(rootCertificateWithoutPrivateKey.LeaseId);</pre></div>

<h5>
<a id="writeread-pki-role" class="anchor" href="#writeread-pki-role" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Write/Read PKI Role</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Create new Role</span>
<span class="pl-k">var</span> roleName = Guid.NewGuid().ToString();

<span class="pl-k">var</span> role = <span class="pl-k">new</span> CertificateRoleDefinition
{
    AllowedDomains = <span class="pl-s"><span class="pl-pds">"</span>example.com<span class="pl-pds">"</span></span>,
    AllowSubdomains = <span class="pl-c1">true</span>,
    MaximumTimeToLive = <span class="pl-s"><span class="pl-pds">"</span>72h<span class="pl-pds">"</span></span>,
};

<span class="pl-k">await</span> vaultClient.PKIWriteNamedRoleAsync(roleName, role, mountpoint);

<span class="pl-k">var</span> readRole = <span class="pl-k">await</span> vaultClient.PKIReadNamedRoleAsync(roleName, mountpoint);
Assert.Equal(role.AllowedDomains, readRole.Data.AllowedDomains);
</pre></div>

<h5>
<a id="generate-pki-credentials" class="anchor" href="#generate-pki-credentials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generate PKI Credentials</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> certificateCredentials =
    <span class="pl-k">await</span>
        vaultClient.PKIGenerateDynamicCredentialsAsync(roleName,
            <span class="pl-k">new</span> CertificateCredentialsRequestOptions
            {
                CommonName = commonName,
                CertificateFormat = CertificateFormat.pem
            }, mountpoint);

<span class="pl-k">var</span> privateKey = certificateCredentials.Data.PrivateKey;
</pre></div>

<h4>
<a id="postgresql-secret-backend" class="anchor" href="#postgresql-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PostgreSql Secret Backend</h4>

<h5>
<a id="configuring-a-postgresql-backend" class="anchor" href="#configuring-a-postgresql-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuring a PostgreSql Backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// mount the backend</span>
<span class="pl-k">var</span> mountPoint = <span class="pl-s"><span class="pl-pds">"</span>postgresql<span class="pl-pds">"</span></span> + Guid.NewGuid();
<span class="pl-k">var</span> backend = <span class="pl-k">new</span> SecretBackend
{
    MountPoint = mountPoint,
    BackendType = SecretBackendType.PostgreSql,
};

<span class="pl-k">await</span> vaultClient.MountSecretBackendAsync(backend);

<span class="pl-k">await</span> vaultClient.PostgreSqlConfigureCredentialLeaseSettingsAsync(<span class="pl-k">new</span> CredentialLeaseSettings()
{
    LeaseDuration = <span class="pl-s"><span class="pl-pds">"</span>1h<span class="pl-pds">"</span></span>,
    MaximumLeaseDuration = <span class="pl-s"><span class="pl-pds">"</span>2h<span class="pl-pds">"</span></span>
}, mountPoint);

<span class="pl-c">// configure root connection info to create/manage roles and generate credentials</span>
<span class="pl-k">await</span> vaultClient.PostgreSqlConfigureConnectionAsync(<span class="pl-k">new</span> PostgreSqlConnectionInfo
{
    ConnectionString = <span class="pl-s"><span class="pl-pds">"</span>con_string<span class="pl-pds">"</span></span>,
    MaximumOpenConnections = <span class="pl-c1">5</span>
}, mountPoint);

<span class="pl-k">var</span> sql = <span class="pl-s"><span class="pl-pds">"</span>CREATE ROLE <span class="pl-cce">\"</span>{{name}}<span class="pl-cce">\"</span> WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT SELECT ON ALL TABLES IN SCHEMA public TO <span class="pl-cce">\"</span>{{name}}<span class="pl-cce">\"</span>;<span class="pl-pds">"</span></span>;

<span class="pl-c">// create a named role</span>
<span class="pl-k">var</span> postgreSqlRole = <span class="pl-s"><span class="pl-pds">"</span>postgresql-readonly-role<span class="pl-pds">"</span></span>;

<span class="pl-k">await</span> vaultClient.PostgreSqlWriteNamedRoleAsync(postgreSqlRole, <span class="pl-k">new</span> PostgreSqlRoleDefinition()
{
    Sql = sql
}, mountPoint);

<span class="pl-k">var</span> readRole = <span class="pl-k">await</span> vaultClient.PostgreSqlReadNamedRoleAsync(postgreSqlRole, mountPoint);
Assert.Equal(sql, readRole.Data.Sql);</pre></div>

<h5>
<a id="generate-postgresql-credentials" class="anchor" href="#generate-postgresql-credentials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generate PostgreSql Credentials</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> postgreSqlCredentials = <span class="pl-k">await</span> vaultClient.PostgreSqlGenerateDynamicCredentialsAsync(postgreSqlRole, backend.MountPoint);

Assert.NotNull(postgreSqlCredentials.LeaseId);
Assert.NotNull(postgreSqlCredentials.Data.Username);
Assert.NotNull(postgreSqlCredentials.Data.Password);
</pre></div>

<h4>
<a id="ssh-secret-backend" class="anchor" href="#ssh-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SSH Secret Backend</h4>

<h5>
<a id="configuring-a-ssh-backend" class="anchor" href="#configuring-a-ssh-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuring a SSH Backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// mount the backend</span>
<span class="pl-k">var</span> sshKeyName = Guid.NewGuid().ToString();
<span class="pl-k">var</span> sshRoleName = Guid.NewGuid().ToString();

<span class="pl-k">var</span> mountPoint = <span class="pl-s"><span class="pl-pds">"</span>ssh<span class="pl-pds">"</span></span> + Guid.NewGuid();
<span class="pl-k">var</span> backend = <span class="pl-k">new</span> SecretBackend
{
    BackendType = SecretBackendType.SSH,
    MountPoint = mountPoint,
};

<span class="pl-k">await</span> vaultClient.MountSecretBackendAsync(backend);

<span class="pl-c">// configure key and role</span>
<span class="pl-k">var</span> privateKey = <span class="pl-s"><span class="pl-pds">@"-----BEGIN RSA PRIVATE KEY----- key ---"</span></span>;

<span class="pl-k">var</span> ip = <span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> user = <span class="pl-s"><span class="pl-pds">"</span>rajan<span class="pl-pds">"</span></span>;

<span class="pl-k">await</span> vaultClient.SSHWriteNamedKeyAsync(sshKeyName, privateKey, mountPoint);
<span class="pl-k">await</span> vaultClient.SSHWriteNamedRoleAsync(sshRoleName, <span class="pl-k">new</span> SSHOTPRoleDefinition
{
    RoleDefaultUser = user,
    CIDRValues = <span class="pl-s"><span class="pl-pds">"</span>127.0.0.1/10<span class="pl-pds">"</span></span>,
}, mountPoint);

<span class="pl-k">var</span> role = <span class="pl-k">await</span> vaultClient.SSHReadNamedRoleAsync(sshRoleName, mountPoint);
Assert.True(role.Data.KeyTypeToGenerate == SSHKeyType.otp);
</pre></div>

<h5>
<a id="generate-ssh-credentials" class="anchor" href="#generate-ssh-credentials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generate SSH Credentials</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> credentials = <span class="pl-k">await</span>
    vaultClient.SSHGenerateDynamicCredentialsAsync(sshRoleName, ip,
        sshBackendMountPoint: mountPoint);

Assert.Equal(user, credentials.Data.Username);
</pre></div>

<h4>
<a id="transit-secret-backend" class="anchor" href="#transit-secret-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Transit Secret Backend</h4>

<h5>
<a id="configuring-a-transit-backend" class="anchor" href="#configuring-a-transit-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuring a Transit Backend</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// mount the backend</span>
<span class="pl-k">var</span> backend = <span class="pl-k">new</span> SecretBackend
{
    BackendType = SecretBackendType.Transit,
    MountPoint = <span class="pl-s"><span class="pl-pds">"</span>transit<span class="pl-pds">"</span></span> + Guid.NewGuid(),
};

<span class="pl-k">await</span> vaultClient.MountSecretBackendAsync(backend);

<span class="pl-c">// create encryption key</span>
<span class="pl-k">var</span> keyName = <span class="pl-s"><span class="pl-pds">"</span>test_key<span class="pl-pds">"</span></span> + Guid.NewGuid();
<span class="pl-k">var</span> context = <span class="pl-s"><span class="pl-pds">"</span>context1<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> plainText = <span class="pl-s"><span class="pl-pds">"</span>raja<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> encodedPlainText = Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText));

<span class="pl-k">await</span> vaultClient.TransitCreateEncryptionKeyAsync(keyName, <span class="pl-c1">true</span>, backend.MountPoint);
<span class="pl-k">var</span> keyInfo = <span class="pl-k">await</span> vaultClient.TransitGetEncryptionKeyInfoAsync(keyName, backend.MountPoint);

Assert.Equal(keyName, keyInfo.Data.Name);
Assert.True(keyInfo.Data.MustUseKeyDerivation);
Assert.False(keyInfo.Data.IsDeletionAllowed);

<span class="pl-c">// configure the key</span>
<span class="pl-k">await</span> vaultClient.TransitConfigureEncryptionKeyAsync(keyName, isDeletionAllowed: <span class="pl-c1">true</span>, transitBackendMountPoint: backend.MountPoint);

keyInfo = <span class="pl-k">await</span> vaultClient.TransitGetEncryptionKeyInfoAsync(keyName, backend.MountPoint);
Assert.True(keyInfo.Data.IsDeletionAllowed);
</pre></div>

<h5>
<a id="encryptdecrypt-text" class="anchor" href="#encryptdecrypt-text" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Encrypt/Decrypt text</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> cipherText = <span class="pl-k">await</span> vaultClient.TransitEncryptAsync(keyName, encodedPlainText, context, transitBackendMountPoint: backend.MountPoint);

<span class="pl-k">var</span> plainText2 = Encoding.UTF8.GetString(Convert.FromBase64String((<span class="pl-k">await</span> vaultClient.TransitDecryptAsync(keyName, cipherText.Data.CipherText, context, backend.MountPoint)).Data.PlainText));

Assert.Equal(plainText, plainText2);</pre></div>

<h5>
<a id="other-transit-operations" class="anchor" href="#other-transit-operations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other Transit Operations</h5>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">await</span> vaultClient.TransitRotateEncryptionKeyAsync(keyName, backend.MountPoint);
<span class="pl-k">var</span> cipherText2 = <span class="pl-k">await</span> vaultClient.TransitEncryptAsync(keyName, encodedPlainText, context, transitBackendMountPoint: backend.MountPoint);

Assert.NotEqual(cipherText.Data.CipherText, cipherText2.Data.CipherText);

<span class="pl-k">var</span> cipherText3 = <span class="pl-k">await</span> vaultClient.TransitRewrapWithLatestEncryptionKeyAsync(keyName, cipherText.Data.CipherText, context, backend.MountPoint);

<span class="pl-k">var</span> newKey1 = <span class="pl-k">await</span> vaultClient.TransitCreateDataKeyAsync(keyName, <span class="pl-c1">false</span>, context, <span class="pl-c1">128</span>, backend.MountPoint);
Assert.Null(newKey1.Data.PlainTextKey);

newKey1 = <span class="pl-k">await</span> vaultClient.TransitCreateDataKeyAsync(keyName, <span class="pl-c1">true</span>, context, <span class="pl-c1">128</span>, backend.MountPoint);
Assert.NotNull(newKey1.Data.PlainTextKey);

<span class="pl-k">await</span> vaultClient.TransitDeleteEncryptionKeyAsync(keyName, backend.MountPoint);
</pre></div>

<h3>
<a id="audit-backends-all-of-them-are-supported" class="anchor" href="#audit-backends-all-of-them-are-supported" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Audit Backends (All of them are supported)</h3>

<ul>
<li>VaultSharp supports all the audit backends supported by the Vault Service 0.4.0</li>
<li>Here is a sample to instantiate the vault client with each of the audit backends.</li>
</ul>

<h4>
<a id="file-audit-backend" class="anchor" href="#file-audit-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>File Audit Backend</h4>

<div class="highlight highlight-source-cs"><pre>
<span class="pl-k">var</span> audits = (<span class="pl-k">await</span> vaultClient.GetAllEnabledAuditBackendsAsync()).ToList();

<span class="pl-c">// enable new file audit</span>
<span class="pl-k">var</span> newFileAudit = <span class="pl-k">new</span> FileAuditBackend
{
    BackendType = AuditBackendType.File,
    Description = <span class="pl-s"><span class="pl-pds">"</span>store logs in a file - test cases<span class="pl-pds">"</span></span>,
    Options = <span class="pl-k">new</span> FileAuditBackendOptions
    {
        FilePath = <span class="pl-s"><span class="pl-pds">"</span>/var/log/file<span class="pl-pds">"</span></span>
    }
};

<span class="pl-k">await</span> vaultClient.EnableAuditBackendAsync(newFileAudit);

<span class="pl-c">// get audits</span>
<span class="pl-k">var</span> newAudits = (<span class="pl-k">await</span> vaultClient.GetAllEnabledAuditBackendsAsync()).ToList();
Assert.Equal(audits.Count + <span class="pl-c1">1</span>, newAudits.Count);

<span class="pl-c">// hash with audit</span>
<span class="pl-k">var</span> hash = <span class="pl-k">await</span> vaultClient.HashWithAuditBackendAsync(newFileAudit.MountPoint, <span class="pl-s"><span class="pl-pds">"</span>testinput<span class="pl-pds">"</span></span>);
Assert.NotNull(hash);

<span class="pl-c">// disabled audit</span>
<span class="pl-k">await</span> vaultClient.DisableAuditBackendAsync(newFileAudit.MountPoint);</pre></div>

<h4>
<a id="syslog-audit-backend" class="anchor" href="#syslog-audit-backend" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Syslog Audit Backend</h4>

<div class="highlight highlight-source-cs"><pre>
<span class="pl-c">// enable new syslog audit</span>
<span class="pl-k">var</span> newSyslogAudit = <span class="pl-k">new</span> SyslogAuditBackend
{
    BackendType = AuditBackendType.Syslog,
    Description = <span class="pl-s"><span class="pl-pds">"</span>syslog audit - test cases<span class="pl-pds">"</span></span>,
    Options = <span class="pl-k">new</span> SyslogAuditBackendOptions()
};

<span class="pl-k">await</span> vaultClient.EnableAuditBackendAsync(newSyslogAudit);

<span class="pl-c">// get audits</span>
<span class="pl-k">var</span> newAudits2 = (<span class="pl-k">await</span> vaultClient.GetAllEnabledAuditBackendsAsync()).ToList();
Assert.Equal(<span class="pl-c1">1</span>, newAudits2.Count);

<span class="pl-c">// disabled audit</span>
<span class="pl-k">await</span> vaultClient.DisableAuditBackendAsync(newSyslogAudit.MountPoint);

<span class="pl-c">// get audits</span>
<span class="pl-k">var</span> oldAudits2 = (<span class="pl-k">await</span> vaultClient.GetAllEnabledAuditBackendsAsync()).ToList();
Assert.Equal(audits.Count, oldAudits2.Count);
</pre></div>

<h3>
<a id="more-administrative--other-operations" class="anchor" href="#more-administrative--other-operations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>More Administrative &amp; Other operations</h3>

<ul>
<li>VaultSharp supports all the operations supported by the Service.</li>
<li>These include administrative ones like Inititalize, Unseal, Seal etc.</li>
<li>Here are some samples.</li>
</ul>

<div class="highlight highlight-source-cs"><pre>
<span class="pl-k">await</span> noAuthInfoClient.InitializeAsync(<span class="pl-c1">5</span>, <span class="pl-c1">3</span>, <span class="pl-c1">null</span>);
<span class="pl-k">await</span> vaultClient.SealAsync();

<span class="pl-k">await</span> vaultClient.UnsealAsync(masterKey); <span class="pl-c">// need to run this in a loop for all master keys</span>
<span class="pl-k">await</span> vaultClient.UnsealQuickAsync(allMasterKeys);  <span class="pl-c">// unseals the Vault in 1 shot.</span>

<span class="pl-k">await</span> vaultClient.GetSealStatusAsync();

<span class="pl-c">// all policy operations</span>

<span class="pl-c">// write a new policy</span>
<span class="pl-k">var</span> newPolicy = <span class="pl-k">new</span> Policy
{
    Name = <span class="pl-s"><span class="pl-pds">"</span>gubdu<span class="pl-pds">"</span></span>,
    Rules = <span class="pl-s"><span class="pl-pds">"</span>path <span class="pl-cce">\"</span>sys/*<span class="pl-cce">\"</span> {  policy = <span class="pl-cce">\"</span>deny<span class="pl-cce">\"</span> }<span class="pl-pds">"</span></span>
};

<span class="pl-k">await</span> vaultClient.WritePolicyAsync(newPolicy);

<span class="pl-c">// get new policy</span>
<span class="pl-k">var</span> newPolicyGet = <span class="pl-k">await</span> vaultClient.GetPolicyAsync(newPolicy.Name);
Assert.Equal(newPolicy.Rules, newPolicyGet.Rules);

<span class="pl-c">// write updates to a new policy</span>
newPolicy.Rules = <span class="pl-s"><span class="pl-pds">"</span>path <span class="pl-cce">\"</span>sys/*<span class="pl-cce">\"</span> {  policy = <span class="pl-cce">\"</span>read<span class="pl-cce">\"</span> }<span class="pl-pds">"</span></span>;

<span class="pl-k">await</span> vaultClient.WritePolicyAsync(newPolicy);

<span class="pl-c">// get new policy</span>
newPolicyGet = <span class="pl-k">await</span> vaultClient.GetPolicyAsync(newPolicy.Name);
Assert.Equal(newPolicy.Rules, newPolicyGet.Rules);

<span class="pl-c">// delete policy</span>
<span class="pl-k">await</span> vaultClient.DeletePolicyAsync(newPolicy.Name);
</pre></div>

<h3>
<a id="in-conclusion" class="anchor" href="#in-conclusion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>In Conclusion</h3>

<ul>
<li>If the above documentation doesn't help you, feel free to create an issue or email me. <a href="https://github.com/rajanadar/VaultSharp/issues/new">https://github.com/rajanadar/VaultSharp/issues/new</a>
</li>
<li>Also, the Intellisense on IVaultClient class should help. I have tried to add a lot of documentation.</li>
</ul>

<p>Happy Coding folks!</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/rajanadar/VaultSharp">Vaultsharp</a> is maintained by <a href="https://github.com/rajanadar">rajanadar</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-72715364-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
